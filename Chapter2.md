# Chapter2 变量和基本类型

## 2.1 基本内置类型

1. C++算数类型表：

   | 类型        | 含义           | 最小尺寸（至少） |
   | :---------- | :------------- | :--------------- |
   | bool        | 布尔           | Not defined      |
   | char        | 字符           | 8 bit            |
   | wchar_t     | 宽字符         | 16 bit           |
   | char16_t    | Unicode字符    | 16 bit           |
   | char32_t    | Unicode字符    | 32 bit           |
   | short       | 短整型         | 16 bit           |
   | int         | 整型           | 16 bit           |
   | long        | 长整型         | 16 bit           |
   | long long   | 长整型         | 64 bit           |
   | float       | 单精度浮点数   | 至少6位有效数字  |
   | double      | 双精度浮点数   | 至少10位有效数字 |
   | long double | 扩展精度浮点数 | 至少10位有效数字 |

1. 字符类型：
   - 一个char的空间应确保可以存放机器**基本字符集**中任意字符对应的数字值，也就是说一个char的大小刚好和一个机器字节一样（1 byte）
  
   - wchar_t类型用于确保可以存放机器**最大**扩展字符集中的任意一个字符
  
   - char16_t和char32_t为unicode字符集服务

1. 内置类型的机器实现
   - 可寻址的最小内存块称为字节（byte），存储的基本单元称为字（Word）
  
   - 大多数机器的字节由8 bit组成，字则有32或者64 bit，也就是4或8字节

1. 通常float以一个字（word）来表示，double由两个字（2 word）来表示（64 bit），long double则有3或4个字。long double通常被用于有特殊浮点需求的硬件。

1. 符号类型
   - 带符号类型（signed）可以表示整数、负数或者0，无符号则只能表示大于0的数
  
   - int、short、long和long long都是带符号的，前面加上unsigned就是无符号类型
  
   - **unsigned int可以简写成unsigned**
  
   - char也有char， unsigned char， signed char。但是此处**signed char 和 char类型不一样**，char实际上只有signed char和unsigned char，而char则由编译器决定表示两种中的哪一种
  
   - 无符号类型所有bit都用来存储值（首bit不是符号位）
  
   - 为保证正负值的表示范围平衡，8 bit的signed char虽然理论上可以表示-128 到 128，但实际上是-128 到 127（**0算作正方向上的值从而使得正负范围平衡**）

1. <b> 类型选择的建议：
   - 当明确知道数值不为负，选用unsigned
  
   - 优先使用int。short太短，long长度往往和int相同，过长数据则选用long long
  
   - 算术表达式中不要选择char或者bool（因为char在不同的机器上可能表现signed或者
  unsigned，如果不得不使用，明确是signed char还是unsigned char）
   - 浮点运算优先使用double，float常常精度不够，两者计算代价相差不大，某些机器double更快
  
   - 往往不需要long double精度，而且运行消耗比较大

1. 类型转换
   - 当用非布尔类型的算数值为布尔值赋值时，只有值为0时布尔值才为false，其他为true
   - 当把浮点数赋值给整数类型时，结果只保留小数点前的部分
   - 当我们把一个整数赋给浮点数时，小数记为0，如果整数空间超过浮点类型的容量，可能会导致精度损失
   - unsigned char表示0-256，如果赋值超出范围，比如-1，那么我们表示的数与256取模获得的余数为255（关于什么是取模，如何计算出255，看第8条）
   - 如果我们赋值给signer char超出范围，那么结果是undefined（未定义的）
  
      ```c++
      bool b = 42; // b为真
      int i = b; // i为1
      i = 3.15; // i为3
      double pi = i; // pi为3.0
      unsigned char c = -1; // 假设char占8bit，那么c为255
      signed char c2 = 256; //假设char占8bit，那么c2为未定义的

      int i = 42;
      if(i)  // 此时i会被编译器自动转换为true
          i = 0;
      ```

1. 取模定义

    >对于整数a，b来说，取模运算或者求余运算的方法要分如下两步：<br/>1.求整数商：c=a/b<br/>2.计算模或者余数：r=a-(c*b)<br/>求模运算和求余运算在第一步不同<br/>取余运算在计算商值向0方向舍弃小数位<br/>取模运算在计算商值向负无穷方向舍弃小数位<br/>例如：4/(-3)约等于-1.3<br/>在取余运算时候商值向0方向舍弃小数位为-1<br/>在取模运算时商值向负无穷方向舍弃小数位为-2<br/>所以<br/>4rem(-3)=1<br/>4mod(-3)=-2

    - 根据上方定义，$(-1) mod 256$ 第一步计算商为 $\frac{-1}{256}$，取模向负无穷舍弃小数位则为-1，所以此时取模的值就等于$-1 - (-1) * 256 = 255$。

1. 当一个算术表达式中既有无符号数又有int值的时候，int值会被自动转换成无符号数。 

   ```c++
   unsigned u = 10;
   int i = -42;
   cout << i + 1 <<endl; // 输出-84
   cout <<u + i <<endl; // 如果int占32bit，输出4294967264
   ```

   - 此处u + i时，i自动被转换成unsigned int，但-42超出0到$2^{32}$（也就是4294967296）的范围，于是相对于4294967296取模，按照上述方法，先求得商为$\frac{-42}{4294967296}$，向负无穷取值为-1，然后求得模的值为4294967254，加上u的10，算得结果4294967264。
   - 由此而言，我们一定要**确保unsigned的数值不能为负数,最好不要混用带符号和不带符号类型**。  

1. 当把unsigned值应用于for循环时:

    ```c++
    for(unsigned u = 10; u >= 0; --u){
      cout << u << endl; // 此时u永远不会小于0，因为当u=0后再减一，会获得求模后的正数
    }
    ```

    - 要避免这种情况一般用while代替for循环，同时将判断语句设置为u大于1
  
    ```c++
    unsigned u = 10;
    while( u > 1){
      --u;
      cout << u << endl; 
    }
    ```

1. 字面值常量：
   - 十进制字面值是带符号数，八进制和十六进制极可能带符号也可能不带符号
   - 十进制字面值类型是int、long、long long中能容下该数值的最小者
   - 八进制和十六进制是int、unsigned int、long、unsigned long、long long、unsigned long long中能容下该数值的尺寸最小者
   - 浮点型字面值是double

1. 字面值常量表
    - 前缀
  
   | 前缀 | 含义          | 类型     |
   | ---- | ------------- | -------- |
   | u    | Unicode16字符 | char16_t |
   | U    | Unicode32字符 | char32_t |
   | L    | 宽字符        | wchar_t  |
   | u8   | UTF-8         | char     |

    - 后缀（尽量使用L来代替小写的l，因为小写的l像数字1）

    | 后缀整型 | 最小匹配类型 |
    | -------- | ------------ |
    | u or U   | unsigned     |
    | l or L   | long         |
    | ll or LL | long long    |

    | 后缀浮点型 | 类型        |
    | ---------- | ----------- |
    | f or F     | float       |
    | l or L     | long double |

1. 例子：

    ```c++
    L'a'; // 宽字符字面值，类型是wchar_t
    u8"Hi"; // utf-8字符串字面值
    42ULL; // 无符号整型字面值，后缀，所以是unsigned long long
    1E-3F; // 单精度浮点数字面值，float
    3.14159L; // 扩展精度浮点型字面值，类型是long double
    ```

1. true和false是布尔类型字面值，nullptr是指针字面值

## 2.2 变量

1. 初始化和赋值都使用“=”，然而初始化不是赋值，初始化的含义是创建变量的同时赋予一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

1. c++11的新标准加入了“{}”来初始化变量，这种初始化形式被称为列表初始化（list initialization）

1. 当使用列表初始化且初始值存在丢失信息的风险，编译器会报错。

    ```c++
    long double ld = 3.1415123;
    int a{ld}, b{ld}; // 报错，会导致信息损失
    int c(ld), d(ld); // 通过，忽略已发生的信息损失
    ```

1. 当定义变量时没有定义初值，那么变量会被默认初始化。如果内置变量未被初始化，且其在任何函数体之外，变量会被初始化为0。例外是，定义在函数体内部的内置类型变量将不被初始化，而该值就是未被定义的（undefined），此时拷贝或引用将发生错误。**建议初始化每一个内置类型的变量**。

1. 每个类各自决定其初始化对象的方式，由它自己决定初始化的值到底是什么。例如string类如果没有初始化那么将指定初始值为一个空串。

1. c++是分离式编译机制，允许将程序分割成若干文件且各自可以独立编译，此时就需要文件间共享代码。于是c++将变量声明（declaration）和定义（definition）分离开来：
   - 声明使得名字为程序所知，即如果想使用别处定义的名字则必须在该文件中包含对其的声明
   - 定义则负责创建与名字关联的实体
   - 变量规定类型和名字，定义在此之上还申请了内存空间，也可能直接为变量赋值
   - 如果只想声明，需在名字前加上extern关键字，如果此时初始化了则成为定义
   - 函数内部如果初始化一个extern关键字标记的变量将引发错误

    ```c++
    extern int i; // 仅声明变量i
    int j;  // 声明并定义j
    extern int p = 10; // 定义p
    ```

1. **变量只能被定义一次，但可以多次声明。当变量在多个文件中被同时使用时，需要在一个文件中定义，其他的都将只能且必须声明**

1. c++标志符：
   - 必须以字母或下划线开头（定义在函数体外的标识符不能以下划线开头）
   - 对大小写敏感
   - 不能使用c++保留字
   - 不能连续出现两个下划线
   - 不能以下划线连接大写字母开头

1. 命名规范：
   - 标识符要能体现实际含义
   - 变量名一般用小写字母
   - 自定义类一般以大写字母开头
   - 多个单词构成时中间应该有明显区分（例如下划线）

1. c++中大多数作用域都以花括号分隔。名字的有效区域始于名字的声明，以声明语句所在的作用域末端为结束

1. 如果全局变量和函数内局部变量命名冲突，则在函数内未定义变量前使用全局，定义后优先使用局部变量

## 2.3 复合类型

1. 

## 2.4 const限定符

## 2.5 处理类型

## 2.6 自定义数据结构