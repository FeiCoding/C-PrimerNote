# Chapter2 变量和基本类型

## 2.1 基本内置类型

1. C++算数类型表：

   | 类型        | 含义           | 最小尺寸（至少） |
   | :---------- | :------------- | :--------------- |
   | bool        | 布尔           | Not defined      |
   | char        | 字符           | 8 bit            |
   | wchar_t     | 宽字符         | 16 bit           |
   | char16_t    | Unicode字符    | 16 bit           |
   | char32_t    | Unicode字符    | 32 bit           |
   | short       | 短整型         | 16 bit           |
   | int         | 整型           | 16 bit           |
   | long        | 长整型         | 16 bit           |
   | long long   | 长整型         | 64 bit           |
   | float       | 单精度浮点数   | 至少6位有效数字  |
   | double      | 双精度浮点数   | 至少10位有效数字 |
   | long double | 扩展精度浮点数 | 至少10位有效数字 |

1. 字符类型：
   - 一个char的空间应确保可以存放机器**基本字符集**中任意字符对应的数字值，也就是说一个char的大小刚好和一个机器字节一样（1 byte）
  
   - wchar_t类型用于确保可以存放机器**最大**扩展字符集中的任意一个字符
  
   - char16_t和char32_t为unicode字符集服务

1. 内置类型的机器实现
   - 可寻址的最小内存块称为字节（byte），存储的基本单元称为字（Word）
  
   - 大多数机器的字节由8 bit组成，字则有32或者64 bit，也就是4或8字节

1. 通常float以一个字节来表示，double由两个字节来表示（64 bit），long double则有3或4个字节。long double通常被用于有特殊浮点需求的硬件。

1. 符号类型
   - 带符号类型（signed）可以表示整数、负数或者0，无符号则只能表示大于0的数
  
   - int、short、long和long long都是带符号的，前面加上unsigned就是无符号类型
  
   - **unsigned int可以简写成unsigned**
  
   - char也有char， unsigned char， signed char。但是此处**signed char 和 char类型不一样**，char实际上只有signed char和unsigned char，而char则由编译器决定表示两种中的哪一种
  
   - 无符号类型所有bit都用来存储值（首bit不是符号位）
  
   - 为保证正负值的表示范围平衡，8 bit的signed char虽然理论上可以表示-128 到 128，但实际上是-128 到 127（**0算作正方向上的值从而使得正负范围平衡**）

1. <b> 类型选择的建议：
   - 当明确知道数值不为负，选用unsigned
  
   - 优先使用int。short太短，long长度往往和int相同，过长数据则选用long long
  
   - 算术表达式中不要选择char或者bool（因为char在不同的机器上可能表现signed或者
  unsigned，如果不得不使用，明确是signed char还是unsigned char）
   - 浮点运算优先使用double，float常常精度不够，两者计算代价相差不大，某些机器double更快
  
   - 往往不需要long double精度，而且运行消耗比较大

1. 类型转换
   - 当用非布尔类型的算数值为布尔值赋值时，只有值为0时布尔值才为false，其他为true
   - 当把浮点数赋值给整数类型时，结果只保留小数点前的部分
   - 当我们把一个整数赋给浮点数时，小数记为0，如果整数空间超过浮点类型的容量，可能会导致精度损失
   - unsigned char表示0-256，如果赋值超出范围，比如-1，那么我们表示的数与256取模获得的余数为255（关于什么是取模，如何计算出255，看第8条）
   - 如果我们赋值给signer char超出范围，那么结果是undefined（未定义的）
  
      ```c++
      bool b = 42; // b为真
      int i = b; // i为1
      i = 3.15; // i为3
      double pi = i; // pi为3.0
      unsigned char c = -1; // 假设char占8bit，那么c为255
      signed char c2 = 256; //假设char占8bit，那么c2为未定义的

      int i = 42;
      if(i)  // 此时i会被编译器自动转换为true
          i = 0;
      ```

1. 取模定义

    >对于整数a，b来说，取模运算或者求余运算的方法要分如下两步：<br/>1.求整数商：c=a/b<br/>2.计算模或者余数：r=a-(c*b)<br/>求模运算和求余运算在第一步不同<br/>取余运算在计算商值向0方向舍弃小数位<br/>取模运算在计算商值向负无穷方向舍弃小数位<br/>例如：4/(-3)约等于-1.3<br/>在取余运算时候商值向0方向舍弃小数位为-1<br/>在取模运算时商值向负无穷方向舍弃小数位为-2<br/>所以<br/>4rem(-3)=1<br/>4mod(-3)=-2

    - 根据上方定义，$(-1) mod 256$ 第一步计算商为 $\frac{-1}{256}$，取模向负无穷舍弃小数位则为-1，所以此时取模的值就等于$-1 - (-1) * 256 = 255$。

1. 当一个算术表达式中既有无符号数又有int值的时候，int值会被自动转换成无符号数。 

   ```c++
   unsigned u = 10;
   int i = -42;
   cout << i + 1 <<endl; // 输出-84
   cout <<u + i <<endl; // 如果int占32bit，输出4294967264
   ```

   - 此处u + i时，i自动被转换成unsigned int，但-42超出0到$2^{32}$（也就是4294967296）的范围，于是相对于4294967296取模，按照上述方法，先求得商为$\frac{-42}{4294967296}$，向负无穷取值为-1，然后求得模的值为4294967254，加上u的10，算得结果4294967264。
   - 由此而言，我们一定要**确保unsigned的数值不能为负数,最好不要混用带符号和不带符号类型**。  

1. 当把unsigned值应用于for循环时:

    ```c++
    for(unsigned u = 10; u >= 0; --u){
      cout << u << endl; // 此时u永远不会小于0，因为当u=0后再减一，会获得求模后的数
    }
    ```

    - 要避免这种情况一般用while代替for同时判断语句设置为大于1
  
    ```c++
    unsigned u = 10;
    while( u > 1){
      --u;
      cout << u << endl; 
    }
    ```

1. 字面值常量
    - 前缀
  
   | 前缀 | 含义          | 类型     |
   | ---- | ------------- | -------- |
   | u    | Unicode16字符 | char16_t |
   | U    | Unicode32字符 | char32_t |
   | L    | 宽字符        | wchar_t  |
   | u8   | UTF-8         | char     |

    - 后缀

    | 后缀整型 | 最小匹配类型 |
    | -------- | ------------ |
    | u or U   | unsigned     |
    | l or L   | long         |
    | ll or LL | long long    |

    | 后缀浮点型 | 类型        |
    | ---------- | ----------- |
    | f or F     | float       |
    | l or L     | long double |

1. 例子：

    ```c++
    L'a'; // 宽字符字面值，类型是wchar_t
    u8"Hi"; // utf-8字符串字面值
    42ULL; // 无符号整型字面值，后缀，所以是unsigned long long
    1E-3F; // 单精度浮点数字面值，float
    3.14159L; // 扩展精度浮点型字面值，类型是long double
    ```

1. 字符和字符串











































## 2.2 变量

## 2.3 复合类型

## 2.4 const限定符

## 2.5 处理类型

## 2.6 自定义数据结构