# chapter 10 泛型算法

## 10.1 概述

1. 大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。

1. 一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。

1. 标准库算法find:

    ```c++
    VI vi = {1, 2, 3, 4, 5};
    auto res = find(vi.cbegin(), vi.cend(), 2);
    cout << "The value is " << (res == vi.cend() ? "not found." : "found") << endl; 
    ```

    find将范围中每个元素与给定值比较，返回指向第一个等于给定值的元素的迭代器。如果范围中无匹配元素，则find返回第二个参数来表示搜索失败。

1. find完全不依赖于容器类型，甚至无需理会保存元素的是不是容器。

1. find用元素类型的"=="运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持"<"运算符。不过我们将会看到，大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。

1. 泛型算法本身不会执行容器的操作，他们只会运行于迭代器之上，执行迭代器的操作，泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：**算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素**。

1. 标准库也会定义一类特殊的迭代器，称为插入器（inserter）。与普通迭代器只能遍历鄋绑定的容器相比，插入器能做更多的事情，当给这类迭代器赋值时，他们会在底层的容器上执行插入操作，因此迭代器可以完成向容器添加元素的效果，但算法自身永远不会做这样的操作。

## 10.2 初始泛型算法

## 10.2.1 只读算法

1. 一些只读算法是accumulate，它定义在头文件numeric中，accumulate函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值，假定vec是一个整数序列，则：

    ```c++
    int sum = accumulate(vec.cbegin(), vec.cend(), 0);
    ```

1. accumulate的第三个参数的类型决定了函数中使用哪个假发运算符以及返回值的类型。序列中的元素类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。上述代码中vec中的元素可以是int或者是double、long long或任何其他可以加到int上的类型。

    ```c++
    // 转换为string类型
    string sum = accumulate(vec.cbegin(), vec.cend(), string(""));
    ```

1. 注意，上述代码不能直接传递一个空串，因为空串的字面值是const char*, const char*并没有定义加法运算。

1. 另一个只读算法是equal，用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素和第二个序列中的每个元素相比较，如果对应元素都相等，则返回true，否则返回false。此算法接受三个迭代器，前两个表示第一个序列中的元素范围，第三个表示第二个序列的首元素。

1. equal可以用来比较两个不同类型的容器中的元素，元素类型不一定一样，只要我们能用“==”来比较两个元素类型即可。例如比较list<string>和list<const char*>。

1. equal基于一个非常重要的假设，它假定第二个序列至少与第一个序列一样长。此算法要求处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。

1. 