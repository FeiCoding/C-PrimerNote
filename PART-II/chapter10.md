# chapter 10 泛型算法

## 10.1 概述

1. 大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。

1. 一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。

1. 标准库算法find:

    ```c++
    VI vi = {1, 2, 3, 4, 5};
    auto res = find(vi.cbegin(), vi.cend(), 2);
    cout << "The value is " << (res == vi.cend() ? "not found." : "found") << endl; 
    ```

    find将范围中每个元素与给定值比较，返回指向第一个等于给定值的元素的迭代器。如果范围中无匹配元素，则find返回第二个参数来表示搜索失败。

1. find完全不依赖于容器类型，甚至无需理会保存元素的是不是容器。

1. find用元素类型的"=="运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持"<"运算符。不过我们将会看到，大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。

1. 泛型算法本身不会执行容器的操作，他们只会运行于迭代器之上，执行迭代器的操作，泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：**算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素**。

1. 标准库也会定义一类特殊的迭代器，称为插入器（inserter）。与普通迭代器只能遍历绑定的容器相比，插入器能做更多的事情，当给这类迭代器赋值时，他们会在底层的容器上执行插入操作，因此迭代器可以完成向容器添加元素的效果，但**算法自身永远不会做这样的操作**。

## 10.2 初始泛型算法

### 10.2.1 只读算法

1. 一种只读算法是accumulate，它定义在头文件numeric中，accumulate函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值，假定vec是一个整数序列，则：

    ```c++
    int sum = accumulate(vec.cbegin(), vec.cend(), 0);
    ```

1. accumulate的第三个参数的类型决定了函数中使用哪个假发运算符以及返回值的类型。**序列中的元素类型必须与第三个参数匹配，或者能够转换为第三个参数的类型**。上述代码中vec中的元素可以是int或者是double、long long或任何其他可以加到int上的类型。

    ```c++
    // 转换为string类型
    string sum = accumulate(vec.cbegin(), vec.cend(), string(""));
    ```

1. 注意，上述代码**不能直接传递一个空串，因为空串的字面值是const char*, const char*并没有定义加法运算**。

1. 另一个只读算法是equal，用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素和第二个序列中的每个元素相比较，如果对应元素都相等，则返回true，否则返回false。此算法接受三个迭代器，前两个表示第一个序列中的元素范围，第三个表示第二个序列的首元素。

1. equal可以用来比较两个不同类型的容器中的元素，元素类型不一定一样，只要我们能用“==”来比较两个元素类型即可。例如比较list<\string>和list<\const char*>。

1. equal基于一个非常重要的假设，它假定第二个序列至少与第一个序列一样长。此算法要求处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。

### 10.2.2 写容器元素的算法

1. 一些算法将新值赋予序列中的元素，当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。**算法不会执行容器操作，因此它们自身不能改变容器的大小。**

1. 算法fill接受一对迭代器表示一个范围，还会接受一个值作为第三个参数，fill将给定的这个值赋予输入序列中的每个元素。

    ```c++
    fill(vec.begin(), vec.end(), 0); // 将每个元素重置为0
    fill(vec.begin(), vec.begin() + vec.size() / 2, 10); // 将vec一半元素变为10
    ```

1. 由于fill向给定输入序列中写入数据，因此，只要我们传递了一个幼小的输入序列，写入操作就是安全的。

1. 用一个单一迭代器表示第二个序列的算法（例如equal算法），都假定第二个序列至少与第一个一样长。**确保算法不会试图访问第二个序列中不存在的元素是程序员的责任**。例如，使用equal算法会将第一个序列中的每个元素与第二个序列中的对应元素进行比较，如果第二个序列是第一个序列的一个子集，则程序会产生一个严重bug，即equal会试图访问第二个序列中末尾之后（不存在）的元素。

1. 函数fill_n接受一个但迭代器、一个计数值和一个值，他将给定值赋予迭代器指向的元素开始的指定个元素。我们可以用fill_n将一个新值赋予vector中的元素。

    ```c++
    vector<int> vec; // 空vector
    fill_n(vec.begin(), vec.size(), 0); // 将所有元素重置为0
    // 下句将产生严重错误
    fill_n(vec.begin(), 10, 0); // 将vec中不存在的10个重置为0
    ```

1. 一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器（insert iterator）。插入迭代器是一种向元素中添加元素的迭代器。

1. 当我们使用一个迭代器向容器元素赋值时，**值被赋予迭代器指向的元素**，而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被**添加到容器中**。

1. back_inserter是定义在头文件iterator中的一个函数。它接受一个指向容器的引用，返回一个该容器绑定的插入迭代器，当我们通过次迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中：

    ```c++
    vector<int> vec;
    auto it = back_inserter(vec); // 通过它赋值会将元素添加到vec中
    *it = 42; // 元素中有一个元素为42
    ```

1. 我们通常使用back_inserter来创建一个迭代器，作为算法的目的为止来使用，例如：

    ```c++
    vector<int> vec;
    fill_n(back_inserter(vec), 10, 0); // 添加10个元素到vec
    ```

1. 拷贝算法是另一个向目的地为止迭代器指向的输出序列中的元素写入数据的算法，此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列中的起始位置。传递给copy的目的序列至少要包含与输入序列一样多的元素：

    ```c++
    int a1[] = {0, 1, 2, 3, 4, 5};
    int a2[sizeof(a1) / sizeof(*a1)]; // 确保a1和a2一样大
    // ret指向拷贝到a2的尾元素之后的位置
    auto ret = copy(begin(a1), end(a1), a2); // 把a1的内容拷贝给a2
    ```

1. replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值，此算法接受4个参数，前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值，她将所有等于第一个值的元素替换为第二个值：

    ```c++
    // 将所有0的元素改为42
    replace(ilst.begin(), ilst.end(), 0, 42);
    ```

1. replace_copy保留原序列不变，此方法接受额外第三个迭代器参数，指出调整后序列的保存位置：

    ```c++
    replace_copy(ilst.cbegin(), ilst.cend(). back_insert(ivec), 0, 52);
    ```

    此调用后，ilst并未改变，ivec包含ilst的一份拷贝，不过原来在ilst中值为0的元素，在ivec中都变为42。

### 10.2.3 重排容器元素的算法

1. 调用sort会重排输入序列中的元素，使之有序。他是利用元素类型的“<"运算符来实现排序的。

1. 使用sort来排序和unique算法来去重：

    ```c++
    sort(words.begin(), words.end());
    // 排列在范围的前部，返回指向不重复区域之后一个位置的迭代器
    auto end_unique = unique(words.begin(), words.end());
    // 使用vector操作erase删除重复单词
    words.erase(end_unique, words.end());
    ```

1. 由于unique是标准库算法，不能直接添加或删除容器内的元素，所以我们必须使用容器操作erase来删除。

## 10.3 定制操作