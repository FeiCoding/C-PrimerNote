# chapter 9 顺序容器

## 9.1 顺序容器概述

1. 顺序容器类型：
   | 容器名称     | 容器简介                                                                   |
   | ------------ | -------------------------------------------------------------------------- |
   | vector       | 可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能会很慢   |
   | deque        | 双端队列，支持快速随机访问，在头尾位置插入或删除很快                       |
   | list         | 双向链表，只支持双向顺序访问，在list中任何位置进行插入或删除都很快         |
   | forward_list | 单项链表，只支持单向顺序访问。在链表任何位置进行插入、删除操作都很快       |
   | array        | 固定大小数组，支持快速随机访问，不能天假或删除元素                         |
   | string       | 与vector相似的容器，但专门用于保存字符，随机访问快，在尾部插入、删除速度快 |

1. list和forward_list两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。作为代价，**这两个容器不支持元素的随机访问**：为了访问一个元素，我们只能遍历整个容器。另外和vector、deque和array相比，这**两个容器的额外内存开销也很大**。

1. string和vector将元素保存在连续的内存空间中。由于元素是连续存储，由元素的下标来计算其地址是非常快速的。但是每次添加或删除元素，需要移动插入、删除位置之后的所有元素来保持连续存储。

1. deque支持随机快速访问。deque在中间位置添加或删除元素的代价可能很高。但是在deque的两段添加或删除元素都是很快的。与list和forward_list添加删除元素的速度相当。

1. 相比于内置数组，array是一种更安全更容易使用的数组类型。array对象的大小是固定的。因此array不支持添加和删除元素以及改变容器大小的操作。

1. forward_list的设计目标是达到与最好的手写的单项链表数据结构相当的性能。因此，forward_list没有size操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，size保证是一个快速的常量时间的操作。

1. **现代c++程序应该使用标准库容器，而不是更原始的数据结构（比如内置数组）。**

1. **通常来说，使用vector是最好的选择，除非有更好的理由选择其他容器。**

1. 选择容器的基本原则：
   - 除非有很好的理由，否则使用vector
   - 如果程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list
   - 如果程序要求随机访问元素，应使用vector或deque
   - 如果程序要求在容器的中间插入或删除元素，应使用list或forward_list
   - 如果程序需要再头尾位置插入或删除元素，但不会再中间位置进行插入或删除操作，则使用deque
   - 如果程序只在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则有两种选择：
      - 先添加到vector，然后进行sort操作
      - 先添加到list，然后拷贝到vector

1. 一般来说，应用中占主导地位的操作（执行的访问操作更多还是插入、删除操作更多）来决定容器类型的选择。

## 9.2 容器库概览

1. 一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。即deque定义头文件deque中，list定义在头文件list中，以此类推。

1. 我们可以定义一个容器，其元素的类型是另一个容器：

    ```c++
    vector<vector<string> > lines; // vector的vector
    ```

1. 顺序容器的构造函数的一个版本可以接受容器大小参数，它使用了元素类型的默认构造函数。但某些类没有默认构造函数，我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能值传递给它一个元素数目参数。

    ```c++
    vector<noDefault> v1(10, init); // 正确：提供了元素初始化器
    vecotr<noDefault> v2(10); // 错误：必须提供一个元素初始化器
    ```

1. 容器操作表：
   | 名称                   | 作用                                                        |
   | ---------------------- | ----------------------------------------------------------- |
   | iterator               | 次容器类型的迭代器类型                                      |
   | const_iterator         | 可以读取元素，但不能修改元素的迭代器类型                    |
   | size_type              | 无符号整数类型，足够保存此种容器类型最大可能容器的大小      |
   | difference_type        | 带符号整数类型，足够保存两个迭代器之间的距离                |
   | value_type             | 元素类型                                                    |
   | reference              | 元素的左值类型：与value_type&含义相同                       |
   | const_reference        | 元素的const左值类型                                         |
   | C c;                   | 默认构造函数，构造空容器                                    |
   | C c1(c2);              | 构造c2的拷贝c1                                              |
   | C c(b, e);             | 构造c，将迭代器b和e指定的范围内的元素拷贝到c（array不支持） |
   | C c{a, b, c}           | 列表初始化c                                                 |
   | c1 = c2                | 将c1中的元素替换成c2中的元素                                |
   | c1 = {a, v, c}         | 将c1中的元素替换为列表中的元素（不适用于array）             |
   | a.swap(b)              | 交换a和b的元素                                              |
   | swap(a, b)             | 与上面相同                                                  |
   | c.size()               | c中的元素个数                                               |
   | c.max_size()           | c可保存的最大元素数目                                       |
   | c.empty()              | 若c中存储了元素，返回false，否则返回true                    |
   | c.insert(args)         | 将args中的元素拷贝进c                                       |
   | c.emplace(init)        | 使用inits构造c中的一个元素                                  |
   | c.erase(args)          | 删除args指定的元素                                          |
   | c.clear()              | 删除c中的所有元素，返回void                                 |
   | ==, !=                 | 所有容器都支持相等（不等）运算符                            |
   | <, <=, >, >=           | 关系运算符（无序关联容器不支持）                            |
   | c.begin(), c.end()     | 返回指向c的首元素和尾元素之后位置的迭代器                   |
   | c.cbegin(), c.cend()   | 返回const_iterator                                          |
   | reverse_iterator       | 按逆序寻址元素的迭代器                                      |
   | const_reverse_iterator | 不能修改元素的逆序迭代器                                    |
   | c.rbegin(), c.rend()   | 返回指向c尾元素和首元素之前位置的迭代器                     |
   | c.crbegin(), c.crend() | 返回const_reverse_iterator                                  |

### 9.2.1 迭代器

1. **forward_list迭代器不支持递减运算符。**

1. 迭代器支持的算术运算符，只能应用于string、vector、deque和array的迭代器。不适用于其他任何容器类型的迭代器。

1. 一个迭代器范围（iterator range）由一堆迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置（one past the last element)。这两个迭代器通常被称为begin和end，或者是first和last，它们标记了容器中元素的一个范围。

1. 第二个迭代器虽然叫last，但并不指向最后一个元素，而是最后一个元素之后的位置。这种元素范围被称为左闭合区间（left-inclusive interval），其标准数学描述为：[begin, end)。

1. 迭代器范围的三种性质：
   - 如果begin和end相等，则范围为空
   - 如果begin和end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素
   - 我们可以对begin递增若干次，使得begin==end

    ```c++
    while(begin != end){
        *begin = val; // 正确：范围非空，因此begin指向第一个元素
        ++begin; // 移动迭代器，获取下一个元素
    }
    ```

1. **list的迭代器不支持大小比较。**

    ```c++
    list<int> lst1;
    list<int>::iterator iter1 = lst1.begin(), iter2 = lst1.end();
    while(iter1 < iter2){ // 错误，使用iter2 != iter2
        // code block
    }
    ```

### 9.2.2 容器类型成员

1. 