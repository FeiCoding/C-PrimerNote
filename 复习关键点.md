# 复习关键点整理

## chapter 2

1. 取模定义

   > 对于整数a，b来说，取模运算或者求余运算的方法要分如下两步：  
   > 1.求整数商：c=a/b  
   > 2.计算模或者余数：r=a-(c*b)  
   > 求模运算和求余运算在第一步不同  
   > 取余运算在计算商值向0方向舍弃小数位  
   > 取模运算在计算商值向负无穷方向舍弃小数位  
   > 例如：4/\(-3\)约等于-1.3  
   > 在取余运算时候商值向0方向舍弃小数位为-1  
   > 在取模运算时商值向负无穷方向舍弃小数位为-2  
   > 所以  
   > 4rem\(-3\)=1  
   > 4mod\(-3\)=-2

1. 当使用列表初始化且初始值存在丢失信息的风险，编译器会报错。

1. 函数内部如果初始化一个extern关键字标记的变量将引发错误（不能在函数体内使用extern）

1. c++标志符：
   * 必须以字母或下划线开头（定义在函数体外的标识符不能以下划线开头）
   * 对大小写敏感
   * 不能使用c++保留字
   * 不能连续出现两个下划线
   * 不能以下划线连接大写字母开头

1. 我们不能直接操作void\*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也无法知道在这个对象上做哪些操作

1. 大部分情况下所有引用类型都必须和与之绑定的对象严格匹配，**引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。**

1. 指针的类型都要和他所指的对象严格匹配。

1. 如果用一个对象**去初始化另一个对象**，则他们**是不是const都无关紧要(只有顶层const会被忽略)** 

1. 如果想在多个文件之间共享const对象，则必须在变量的定义之前添加extern关键字

1. 常量对象只能用常量引用来引用它,而不能使用一般引用

1. **constexpr只能将指针声明成const，而对该指针指向的对象无影响**。(也就是说constexpr是定义一个顶层const)，此时constexpr指针既可以指向常量又可以指向非常量。

    ```cpp
     const int *ptr = nullptr; // 指向常量的指针
     constexpr int *ptr2 = nullptr; // 常量指针，指针本身是常量
    ```

1. auto类型说明符，能让编译器代替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型，所以**auto定义的变量必须有初始值**。

1. auto会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时。

1. 如果希望推断出的auto类型是一个顶层const，必须在前面加上const（const auto）

1. 使用引用实际是初始化引用对象的值，因此编译器会以引用对象的类型作为auto类型。如果想将引用的类型设置为auto，则在变量之前加上& (auto &i = a)

1. decltype处理顶层const和引用的方式与auto不同，decltype会返回变量的类型包括顶层const和引用在内

1. decltype和auto的区别：
   * 处理顶层const和引用的方式不同，auto会忽略顶层const，对于引用返回引用对象类型，而decltype不会忽视，对于引用直接返回引用类型）
   * decltype直接跟上变量则直接返回变量类型，如果decltype加上一或多层括号则会将该变量视为表达式（**decltype的双括号结果永远视为引用**）

     ```cpp
       int i = 1;
       decltype((i)) d; // 双括号，类型为int&
       decltype(i) e; // 类型为int
     ```

## chapter 3

1. string 的成员函数 size()返回的并不是一个 int 或 unsigned，而是 string::size_type 类型的值。size_type 是一种无符号类型的值而且能足够存放下任何 string 对象的大小。所有用于存放 string 类的 size 函数返回值的变量，都应该是 string::size_type 类型的。

1. 由于 size 函数返回的是一个无符号整型数，所以此时如果混用带符号的类型数可能会产生意想不到的后果。

1. 数组维度说明了数组中元素的个数，因此必须大于 0，数组元素的个数也属于数组类型的一部分，编译的时候维度应该是一致的，也就是说，**维度必须是一个常量表达式**：

1. 字符数组的特殊性：使用**字符串字面值**来初始化字符数组时，一定要注意字符串字面值的结尾处还有一个空字符。

   ```cpp
    char a1[] = {'c', '+', '+'}; // 列表初始化，没有空字符
    char a2[] = {'c', '+', '+', '\0'}; // 列表初始化，含有显示的空字符
    char a3[] = "c++"; // 自动添加字符串结束的空字符
    char a4[5] = "Hello"; // 错误，应当设置维度为6来存放额外的‘\0’
   ```

1. 使用数组的时候，编译器一般会把它转换成指针。**当使用数组作为一个 auto 变量的初始值时，推断得到的类型是指针而非数组。**

## chapter 4

1. **一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）来使用。当一个左值被当成右值使用时，实际使用是他的内容（值）。**

1. 使用关键字decltype的时候，如果表达式的求值结果是左值，则得到一个引用类型（假设p是int\*类型，decltype(\*p)返回的是一个引用 int&），如果取地址运算符生成右值，例如decltype(&p)，那么会返回一个int\*\*，也就是一个指向整形指针的指针。

1. 算术运算符能作用于任意算术类型以及任意能转换成为算术类型的类型，**算术运算符的运算对象和求值结果都是右值**。在表达式求值之前，小整数类型的运算对象被提升为较大整数类型，**所有运算对象最终都会转换成同一类型**。

1. 运算符%是取余或取模运算符。**参与取余（%）运算的运算符必须是整数类型**。

1. **c++11新标准规定，商的值一律向0取整。**

1. 对于取模运算符（%）来说，如果 m % n 的运算结果不等于0，则它的符号与m相同。**而 (-m) / n 和 m / (-n) 都等于 -(m / n)，m % (-n) 等于 m % n，(-m) % n 等于 -(m % n)**。

    | 运算     | 结果 |
    | -------- | ---- |
    | 21 % 6   | 3    |
    | 21 % 7   | 0    |
    | -21 % -8 | -5   |
    | 21 % -5  | 1    |

1. 逻辑运算符和关系运算符的运算对象求值结果为右值

1. **如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。**

1. **如果左值是一个内置类型，那么初始值列表最多只能包含一个值**

1. **赋值运算符满足右结合律**：

    ```c++
    int i, j;
    i = j = 0; // 正确，i和j都被赋值为0。 0先被赋值给j，然后j赋值给i
    int *ptr;
    i = ptr = 0; // 错误，不能把int* 赋值给一个int对象

    double d;
    d = i = 3.5; // d是3.0, i是3
    i = d = 3.5; // d是3.5，i是3
    ```

1. 赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号：

1. ++操作的优先级高于解引用(*)。先对pbeg进行++操作，然后再返回其原始值给解引用操作符，此时解引用操作符返回的是pbeg未增加之前的值。此处可以有效避免解引用操作符操作一个先进行++再返回++之后的对象，因为此时对象可能已经指向一个未知的或不存在的元素，导致解引用发生不可预知的错误。

    ```c++
    cout << *iter++ << endl; // 习惯这种操作，更加简洁也更少出错

    cout << *iter << endl; // 尽量避免这种操作
    iter++;
    ```

1. 因为递增运算符和递减运算符会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。

    ```c++
    while(beg != s.end() && !isspace(*beg))
        *beg = toupper(*beg++); // 错误，赋值运算符两端的运算对象都用到了beg，
                                // 并且右侧的运算对象还改变了beg的值，
                                // 此时无法知道先运算左边还是右边

    if(vec[i++] <= vec[i]){
        // 同样地，此时也不能明确左右哪边先运算，也会导致该赋值是未定义的
    }
    ```

1. 4.20例题，假设iter的类型是vector<string>::iterator,说明下面的表达式是否合法：

    ```c++
    *iter++; // 解引用操作优先级小于++，所以先保存值再加加再返回原来的值，合法
    (*iter)++; // 先解引用为string类型，再++，string++无意义，不合法
    *iter.empty(); // 解引用操作优先级小于点操作，先对iter进行empty成员函数，
                   // 指针无该成员函数，不合法
    iter->empty(); // 合法
    ++*iter; // 先进行++，但++操作符操作于*iter解引用的string类型上，无意义
    iter++->empty(); // ++操作符优先级低于箭头操作符，先调用empty成员函数，
                     // 再进行++，合法
    ```

1. 条件运算符的内部允许嵌套另外一个条件运算符。

    ```c++
    string finalgrade = (grad < 60) ? "Fail" : (grad > 90) ? "High Pass" : "Pass";
    ```

1. 条件运算符满足右结合律，意味着运算对象（一般）按照从右向左的顺序组合。因此上述代码中，靠右边的条件运算（grad > 90）构成了左边的条件运算的分支。

1. 条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要再它两端加上括号。

    ```c++
    cout << ((grade < 60) ? "fail" : "pass"); // 输出pass或者fail
    cout << (grade < 60) ? "fail" : "pass"; // 输出0或者1,解释在下条
    cout << grade < 60 ? "fail" : "pass"; // 错误，试图比较cout和60
    ```

1. **左移运算符在右侧插入值为0的二进制位。右移运算符则依赖于运算对象的类型：如果是无符号类型，则在左侧的二进制位插入0，如果是带符号，则左侧插入符号位的副本或值为0的二进制数。具体视环境而定。**

1. 位移操作符满足左结合律，它们的重载版本可以进行IO操作。位移操作的优先级不高不低，介于中间：比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高。因此在一次使用多个运算符时，有必要适当的地方加上括号使其满足我们的要求。

    ```c++
    cout << 42 + 10; // 正确，+优先级更高，因此输出求和的结果
    cout << (10 < 42); // 正确，括号使得运算对象按照我们的期望组合在一起，输出1
    cout << 10 < 42; // 错误：试图比较cout对象和42的大小
    ```

1. sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。

1. 最有意思的是sizeof \*p，首先因为sizeof满足右结合律并且与\*的运算符的优先级一样，所以表达式按照从右向左的顺序组合。也就是说，他等价于sizeof(*p)。其次，因为sizeof不会实际求运算对象的值，所以即使p是一个无效的（未初始化的）指针，也不会有什么影响。**在sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为**，因为指针实际上并没有被真正的使用。sizeof不需要真的解引用指针也能知道他所指对象的类型。

1. 对char或者类型为char的表达式执行sizeof运算，结果为1。

1. 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。

1. sizeof的返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度。

    ```c++
    // 可以用数组的大小除以单个元素的大小得到数组中元素的个数
    constexpr size_t sz = sizeof(ia) / sizeof(*ia);
    int arr2[sz]; // 正确，sizeof返回的是一个常量表达式（数组在声明时长度必须是常量）
    ```

1. 习题4.33:

    someValue ? ++x, ++y : --x, --y
    逗号表达式的优先级是最低的。因此这条表达式也等于：

    (someValue ? ++x, ++y : --x), --y
    如果 someValue的值为真，x 和 y 的值都自增并返回 y 值，然后丢弃 y 值，y递减并返回 y 值。如果 someValue的值为假，x 递减并返回 x 值，然后丢弃 x 值，y递减并返回 y 值。

1. **算术类型之间的隐式转换被设计的尽可能避免损失精度**，很多时候，如果表达式中既有整数又有浮点数那么整型会被转换成浮点型。

1. **指向任意非常量的指针能转换成void\*静态指针**。

1. static_cast:任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。例如，通过将一个运算对象强制转换成double类型以执行浮点数除法：

    ```c++
    double slope = static_cast<double>(j) / i;
    ```

1. 当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时强制类型转换会告诉读者和编译器，我们知道并且不在乎潜在的精度损失。（如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息，但是当执行了显式的类型转换后，警告信息就会被关闭了）

1. 