# 复习关键点整理

## chapter 2

1. 取模定义

   > 对于整数a，b来说，取模运算或者求余运算的方法要分如下两步：  
   > 1.求整数商：c=a/b  
   > 2.计算模或者余数：r=a-(c*b)  
   > 求模运算和求余运算在第一步不同  
   > 取余运算在计算商值向0方向舍弃小数位  
   > 取模运算在计算商值向负无穷方向舍弃小数位  
   > 例如：4/\(-3\)约等于-1.3  
   > 在取余运算时候商值向0方向舍弃小数位为-1  
   > 在取模运算时商值向负无穷方向舍弃小数位为-2  
   > 所以  
   > 4rem\(-3\)=1  
   > 4mod\(-3\)=-2

1. 当使用列表初始化且初始值存在丢失信息的风险，编译器会报错。

1. 函数内部如果初始化一个extern关键字标记的变量将引发错误（不能在函数体内使用extern）

1. c++标志符：
   * 必须以字母或下划线开头（定义在函数体外的标识符不能以下划线开头）
   * 对大小写敏感
   * 不能使用c++保留字
   * 不能连续出现两个下划线
   * 不能以下划线连接大写字母开头

1. 我们不能直接操作void\*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也无法知道在这个对象上做哪些操作

1. 大部分情况下所有引用类型都必须和与之绑定的对象严格匹配，**引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。**

1. 指针的类型都要和他所指的对象严格匹配。

1. 如果用一个对象**去初始化另一个对象**，则他们**是不是const都无关紧要(只有顶层const会被忽略)** 

1. 如果想在多个文件之间共享const对象，则必须在变量的定义之前添加extern关键字

1. 常量对象只能用常量引用来引用它,而不能使用一般引用

1. **constexpr只能将指针声明成const，而对该指针指向的对象无影响**。(也就是说constexpr是定义一个顶层const)，此时constexpr指针既可以指向常量又可以指向非常量。

    ```cpp
     const int *ptr = nullptr; // 指向常量的指针
     constexpr int *ptr2 = nullptr; // 常量指针，指针本身是常量
    ```

1. auto类型说明符，能让编译器代替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型，所以**auto定义的变量必须有初始值**。

1. auto会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时。

1. 如果希望推断出的auto类型是一个顶层const，必须在前面加上const（const auto）

1. 使用引用实际是初始化引用对象的值，因此编译器会以引用对象的类型作为auto类型。如果想将引用的类型设置为auto，则在变量之前加上& (auto &i = a)

1. decltype处理顶层const和引用的方式与auto不同，decltype会返回变量的类型包括顶层const和引用在内

1. decltype和auto的区别：
   * 处理顶层const和引用的方式不同，auto会忽略顶层const，对于引用返回引用对象类型，而decltype不会忽视，对于引用直接返回引用类型）
   * decltype直接跟上变量则直接返回变量类型，如果decltype加上一或多层括号则会将该变量视为表达式（**decltype的双括号结果永远视为引用**）

     ```cpp
       int i = 1;
       decltype((i)) d; // 双括号，类型为int&
       decltype(i) e; // 类型为int
     ```

## chapter 3

1. string 的成员函数 size()返回的并不是一个 int 或 unsigned，而是 string::size_type 类型的值。size_type 是一种无符号类型的值而且能足够存放下任何 string 对象的大小。所有用于存放 string 类的 size 函数返回值的变量，都应该是 string::size_type 类型的。

1. 由于 size 函数返回的是一个无符号整型数，所以此时如果混用带符号的类型数可能会产生意想不到的后果。

1. 数组维度说明了数组中元素的个数，因此必须大于 0，数组元素的个数也属于数组类型的一部分，编译的时候维度应该是一致的，也就是说，**维度必须是一个常量表达式**：

1. 字符数组的特殊性：使用**字符串字面值**来初始化字符数组时，一定要注意字符串字面值的结尾处还有一个空字符。

   ```cpp
    char a1[] = {'c', '+', '+'}; // 列表初始化，没有空字符
    char a2[] = {'c', '+', '+', '\0'}; // 列表初始化，含有显示的空字符
    char a3[] = "c++"; // 自动添加字符串结束的空字符
    char a4[5] = "Hello"; // 错误，应当设置维度为6来存放额外的‘\0’
   ```

1. 使用数组的时候，编译器一般会把它转换成指针。**当使用数组作为一个 auto 变量的初始值时，推断得到的类型是指针而非数组。**

## chapter 4

1. **一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）来使用。当一个左值被当成右值使用时，实际使用是他的内容（值）。**

1. 使用关键字decltype的时候，如果表达式的求值结果是左值，则得到一个引用类型（假设p是int\*类型，decltype(\*p)返回的是一个引用 int&），如果取地址运算符生成右值，例如decltype(&p)，那么会返回一个int\*\*，也就是一个指向整形指针的指针。

1. 算术运算符能作用于任意算术类型以及任意能转换成为算术类型的类型，**算术运算符的运算对象和求值结果都是右值**。在表达式求值之前，小整数类型的运算对象被提升为较大整数类型，**所有运算对象最终都会转换成同一类型**。

1. 运算符%是取余或取模运算符。**参与取余（%）运算的运算符必须是整数类型**。

1. **c++11新标准规定，商的值一律向0取整。**

1. 对于取模运算符（%）来说，如果 m % n 的运算结果不等于0，则它的符号与m相同。**而 (-m) / n 和 m / (-n) 都等于 -(m / n)，m % (-n) 等于 m % n，(-m) % n 等于 -(m % n)**。

    | 运算     | 结果 |
    | -------- | ---- |
    | 21 % 6   | 3    |
    | 21 % 7   | 0    |
    | -21 % -8 | -5   |
    | 21 % -5  | 1    |

1. 逻辑运算符和关系运算符的运算对象求值结果为右值

1. **如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。**

1. **如果左值是一个内置类型，那么初始值列表最多只能包含一个值**

1. **赋值运算符满足右结合律**：

    ```c++
    int i, j;
    i = j = 0; // 正确，i和j都被赋值为0。 0先被赋值给j，然后j赋值给i
    int *ptr;
    i = ptr = 0; // 错误，不能把int* 赋值给一个int对象

    double d;
    d = i = 3.5; // d是3.0, i是3
    i = d = 3.5; // d是3.5，i是3
    ```

1. 赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号：

1. ++操作的优先级高于解引用(*)。先对pbeg进行++操作，然后再返回其原始值给解引用操作符，此时解引用操作符返回的是pbeg未增加之前的值。此处可以有效避免解引用操作符操作一个先进行++再返回++之后的对象，因为此时对象可能已经指向一个未知的或不存在的元素，导致解引用发生不可预知的错误。

    ```c++
    cout << *iter++ << endl; // 习惯这种操作，更加简洁也更少出错

    cout << *iter << endl; // 尽量避免这种操作
    iter++;
    ```

1. 因为递增运算符和递减运算符会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。

    ```c++
    while(beg != s.end() && !isspace(*beg))
        *beg = toupper(*beg++); // 错误，赋值运算符两端的运算对象都用到了beg，
                                // 并且右侧的运算对象还改变了beg的值，
                                // 此时无法知道先运算左边还是右边

    if(vec[i++] <= vec[i]){
        // 同样地，此时也不能明确左右哪边先运算，也会导致该赋值是未定义的
    }
    ```

1. 