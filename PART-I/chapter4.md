# chapter 4 表达式

## 4.1 基础

1. 作用于一个运算对象的运算符是一元运算符，如取地址符（&）和解引用符（\*），作用域两个运算对象的运算符是二元运算符，如相等运算符（==）和乘法运算符（\*）,还有作用域三个运算对象的三元运算符。函数电泳也是一种特殊的运算符，它对运算对象的数量没有限制。

1. 一些符号既能作为一元运算符也能作为二元运算符，比如*号既可以是解引用，也可以是乘号。

1. 即使运算对象的类型不同，只要他们能被转换，也能使用二元运算符进行计算。例如整数变成浮点数，浮点数转换成整数。**小整数类型（如bool、char、short等）通常会被提升成较大的整数类型，主要是int。**

1. C++表达式要不然是右值（rvalue）要不然就是左值（lvalue），左值可以位于赋值语句的左边，而右值不能。在C++中，一个左值表达式的求值结果是一个对象或者一个函数，而以常量对象为代表的某些左值并不能作为赋值语句的左侧运算对象。**归纳：当一个对象被用作右值时，用的是对象的值（内容），而当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。**[左值右值的详解看这篇博客](https://www.cnblogs.com/catch/p/3500678.html)

1. **一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）来使用。当一个左值被当成右值使用时，实际使用是他的内容（值）。**

1. 以下是一些我们常用的需要用到左值的运算符：
    - 赋值运算符需要有个（非常量）左值作为其左侧运算对象，得到的结果也仍然是一个左值。
    - 取地址符（&）作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。
    - 内置引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值。
    - 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值

1. 使用关键字decltype的时候，如果表达式的求值结果是左值，则得到一个引用类型（例如decltype(*p)返回的是一个引用 int&），如果取地址运算符生成右值，例如decltype(&p)，那么会返回一个int**，也就是一个指向整形指针的指针。

1. 表达式中的括号无视运算符的优先级。程序员可以使用括号将某个表达式的某个局部括起来使其得到优先运算。

1. 算术运算符满足结合律，也就是当运算符的优先级相同，将按照从左向右的顺序组合运算对象

1. 对于没有指定执行顺序的运算符来说，**如果表达式指向并修改了同一个对象**，将会引发错误并产生未定义的行为。例如：

    ```c++
    int i = 0;
    cout << i << " " << i++ << endl; // 未定义的
    // 因为程序可能先执行i++再执行i，也可能先执行i再求i++，因此结果产生了不可预知性
    ```

1. 有4种运算符明确规定了运算对象的求值顺序。分别是 '&&' ， '||' ， '？：' ， ','这4种

1. 对于表达式的结合律例如f() + g() * h() + j()的表达式中，如果f\g\h\j是无关函数，他们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制，反之，如果其中某几个函数影响同一对象，则他是一条错误的表达式

## 4.2 算数运算符

1. 算术运算符的优先级（由上至下优先级降低）：

    | 运算符 | 功能     | 用法        |
    | ------ | -------- | ----------- |
    | +      | 一元正号 | + expr      |
    | -      | 一元负号 | - expr      |
    | *      | 乘法     | expr * expr |
    | /      | 除法     | expr / expr |
    | %      | 求余     | expr % expr |
    | +      | 加法     | expr + expr |
    | -      | 减法     | expr - expr |

1. 算术运算符能作用于任意算术类型以及任意能转换成为算术类型的类型，算术运算符的运算对象和求值结果都是右值。在表达式求值之前，小整数类型的运算对象被提升为较大整数类型，所有运算对象最终都会转换成同一类型。

1. 一元正号运算符、加法运算符和减法运算符都能作用于指针。当**一元正号**运算符作用于一个指针或算数值时，返回运算对象值的一个（提升后的）副本。一元负号运算符对运算对象值取负后，返回其（提升后的）副本：

    ```c++
    int i = 1024;
    int k = -i; // k是-1024
    bool b = true;
    bool b2 = -b; // b2是true！！
    ```

1. **上述布尔值b2先被转换成int型1，然后加上‘-’号后变为-1，然后再转换成布尔值则为1（布尔值只有在0的时候为false），所以尽量避免在运算中使用布尔值。**

1. 算术表达式有可能产生未定义的结果，一部分原因是数学性质本身，例如除以0，另一部分源于计算机的特性，例如溢出，当计算的结果超出该类型所能表示的范围时就会溢出。

1. 整数相除结果还是整数，小数部分将被丢弃。例如21/6是3，21/7也是3。

1. 运算符%是取余或取模运算符。参与取余（%）运算的运算符必须是整数类型。

    ```c++
    int ival = 42;
    double dval = 3.14;
    ival % 12;   // 正确，结果是6。
    ival % dval; // 错误， dval是浮点型
    ```

1. **c++11新标准规定，商的值一律向0取整。**

1. 对于取模运算符（%）来说，如果 m % n 的运算结果不等于0，则它的符号与m相同。**而 (-m) / n 和 m / (-n) 都等于 -(m / n)，m % (-n) 等于 m % n，(-m) % n 等于 -(m % n)**。

    | 运算     | 结果 |
    | -------- | ---- |
    | 21 % 6   | 3    |
    | 21 % 7   | 0    |
    | -21 % -8 | -5   |
    | 21 % -5  | 1    |

## 4.3 逻辑和关系运算符

1. 逻辑运算符包含逻辑非（！）逻辑与（&&）逻辑或（||），关系运算符则包含大于小于等于不等于运算符（>, >=, <, <=, ==, !=），两者的返回类型都是布尔值，值为0的运算对象则为假，否则为真。对于这两类运算符来说，**运算对象和求值结果都是右值**。

1. 逻辑与（&&）和逻辑或（||）当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值，这种策略称为短路求值（short-circuit evaluation）:
   - 逻辑与：当且仅当左侧运算对象为真时才对右侧运算对象求值
   - 逻辑或：当且仅当左侧运算对象为假时才对右侧运算对象求值

1. 因为关系运算符的求值结果是布尔值，所以讲几个关系运算符连写在一起会产生意想不到的结果：

    ```c++
    if( i < j < k){
        // 此表达式会先返回i<j的结果，再用该结果和k作比较
        // 例如i<j为真返回1，则再用1<k来返回下一个结果
    }

    // 实际上我们想表达的是下式
    if( i < j && j < k){

    }
    ```

## 4.4 赋值运算符

1. 赋值运算符的左侧运算对象必须是一个可修改的左值。

    ```c++
    int i = 0, j = 0, k = 0;
    const int ci = i; // 这两行都是初始化，而非赋值
    1023 = k; // 错误，字面值是右值
    i + j = 
    k; // 错误， 算术表达式是右值
    ci = k; // 错误， ci是不可修改的常量左值
    ```

1. 赋值运算对象的结果是他的左侧运算对象，并且是一个左值。相应的，结果的类型就是左侧运算对象的类型。**如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。** C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。在这种情况下，**如果左值是一个内置类型，那么初始值列表最多只能包含一个值**，而且该值即使转换的话其所占空间也不应该大于目标类型的空间（比如不能赋值给一个short类型的值超过short的存储的范围）。

    ```c++
    k = {3.14}; // 错误，窄化转换
    vector<int> vi;
    vi = {0, 1, 2, 3}; // 正确，新标准允许这种赋值
    ```

1. 无论左侧运算对象的类型是什么，初始值列表都可以为空，此时，编译器创建一个值初始化的临时量并将其赋值给左侧对象。

1. **赋值运算符满足右结合律**：

    ```c++
    int i, j;
    i = j = 0; // 正确，i和j都被赋值为0。 0先被赋值给j，然后j赋值给i
    int *ptr;
    i = ptr = 0; // 错误，不能把int* 赋值给一个int对象

    double d;
    d = i = 3.5; // d是3.0, i是3
    i = d = 3.5; // d是3.5，i是3
    ```

1. 对于多重赋值语句中的每一个对象，它的类型或者与**右边对象的类型相同**、或者**可由右边对象的类型转换得到**。

1. 赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号：

    ```c++
    int i;
    while( (i = get_val()) != 31){ 
        // code block, 上方条件语句中如果不给赋值语句加上括号，
        // 那么将先判断get_val()和31然后返回布尔值赋值给i
    }
    ```

1. **切勿混淆相等运算符和赋值运算符！** if(i = j) 和 if(i = j)不同，后者是将j赋值给i然后转换成布尔值来进行判断

1. 任何一种符合运算符(+=, -=, \*=, /=, %=, >>=, <<=, &=, ^=, |=)都完全等价于 a = a *op* b。两者的唯一区别在于运算的次数，复合型只运算了一次，而常规运算操作则运算了两次（第一次对右边式子求值，第二次是赋值给左侧的对象）

## 4.5 递增和递减运算符

1. 递增和递减运算符有两种形式：前置版本（++i）和后置版本（i++）。**除非必须，否则不用递增递减的后置版本。**原因在于前置版本把值加1后直接返回并改变了对象，而后置版本则需要先将原始值存储下来，以用于返回这个未修改的值，在这种情况下，如果我们不需要原始值，那么将对内存是一种浪费。

    ```c++
    int i = 0, j;
    j = ++i; // 先对i进行加操作，在赋值给j
    j = i++; // 先保存i的原始值，再对i进行加操作，再把原始值赋值给j
    ```

1. 下面的代码中，++操作的优先级高于解引用（*），因此\*pbeg++等价于\*（pbeg++）。所以此处先对pbeg进行++操作，然后再返回其原始值给解引用操作符，此时解引用操作符返回的是pbeg未增加之前的值。此处可以有效避免解引用操作符操作一个先进行++再返回++之后的对象，因为此时对象可能已经指向一个未知的或不存在的元素，导致解引用发生不可预知的错误。

    ```c++
    cout << *iter++ << endl; // 习惯这种操作，更加简洁也更少出错

    cout << *iter << endl; // 尽量避免这种操作
    iter++;
    ```

1. 因为递增运算符和递减运算符会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。

    ```c++
    while(beg != s.end() && !isspace(*beg))
        *beg = toupper(*beg++); // 错误，赋值运算符两端的运算对象都用到了beg，
                                // 并且右侧的运算对象还改变了beg的值，
                                // 所以该赋值语句是未定义的。
    ```

## 4.6 成员访问运算符