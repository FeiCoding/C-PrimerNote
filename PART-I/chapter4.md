# chapter 4 表达式

## 4.1 基础

1. 作用于一个运算对象的运算符是一元运算符，如取地址符（&）和解引用符（\*），作用域两个运算对象的运算符是二元运算符，如相等运算符（==）和乘法运算符（\*）,还有作用域三个运算对象的三元运算符。函数电泳也是一种特殊的运算符，它对运算对象的数量没有限制。

1. 一些符号既能作为一元运算符也能作为二元运算符，比如*号既可以是解引用，也可以是乘号。

1. 即使运算对象的类型不同，只要他们能被转换，也能使用二元运算符进行计算。例如整数变成浮点数，浮点数转换成整数。**小整数类型（如bool、char、short等）通常会被提升成较大的整数类型，主要是int。**

1. C++表达式要不然是右值（rvalue）要不然就是左值（lvalue），左值可以位于赋值语句的左边，而右值不能。在C++中，一个左值表达式的求值结果是一个对象或者一个函数，而以常量对象为代表的某些左值并不能作为赋值语句的左侧运算对象。**归纳：当一个对象被用作右值时，用的是对象的值（内容），而当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。**[左值右值的详解看这篇博客](https://www.cnblogs.com/catch/p/3500678.html)

1. **一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）来使用。当一个左值被当成右值使用时，实际使用是他的内容（值）。**

1. 以下是一些我们常用的需要用到左值的运算符：
    - 赋值运算符需要有个（非常量）左值作为其左侧运算对象，得到的结果也仍然是一个左值。
    - 取地址符（&）作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。
    - 内置引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值。
    - 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值

1. 使用关键字decltype的时候，如果表达式的求值结果是左值，则得到一个引用类型（例如decltype(*p)返回的是一个引用 int&），如果取地址运算符生成右值，例如decltype(&p)，那么会返回一个int**，也就是一个指向整形指针的指针。

1. 表达式中的括号无视运算符的优先级。程序员可以使用括号将某个表达式的某个局部括起来使其得到优先运算。

1. 算术运算符满足结合律，也就是当运算符的优先级相同，将按照从左向右的顺序组合运算对象

1. 对于没有指定执行顺序的运算符来说，**如果表达式指向并修改了同一个对象**，将会引发错误并产生未定义的行为。例如：

    ```c++
    int i = 0;
    cout << i << " " << i++ << endl; // 未定义的
    // 因为程序可能先执行i++再执行i，也可能先执行i再求i++，因此结果产生了不可预知性
    ```

1. 有4种运算符明确规定了运算对象的求值顺序。分别是 '&&' ， '||' ， '？：' ， ','这4种

1. 对于表达式的结合律例如f() + g() * h() + j()的表达式中，如果f\g\h\j是无关函数，他们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制，反之，如果其中某几个函数影响同一对象，则他是一条错误的表达式

## 4.2 算数运算符

1. 算术运算符的优先级（由上至下优先级降低）：

    | 运算符 | 功能     | 用法        |
    | ------ | -------- | ----------- |
    | +      | 一元正号 | + expr      |
    | -      | 一元负号 | - expr      |
    | *      | 乘法     | expr * expr |
    | /      | 除法     | expr / expr |
    | %      | 求余     | expr % expr |
    | +      | 加法     | expr + expr |
    | -      | 减法     | expr - expr |

1. 算术运算符能作用于任意算术类型以及任意能转换成为算术类型的类型，算术运算符的运算对象和求值结果都是右值。在表达式求值之前，小整数类型的运算对象被提升为较大整数类型，所有运算对象最终都会转换成同一类型。

1. 一元正号运算符、加法运算符和减法运算符都能作用于指针。当**一元正号**运算符作用于一个指针或算数值时，返回运算对象值的一个（提升后的）副本。一元负号运算符对运算对象值取负后，返回其（提升后的）副本：

    ```c++
    int i = 1024;
    int k = -i; // k是-1024
    bool b = true;
    bool b2 = -b; // b2是true！！
    ```

1. **上述布尔值b2先被转换成int型1，然后加上‘-’号后变为-1，然后再转换成布尔值则为1（布尔值只有在0的时候为false），所以尽量避免在运算中使用布尔值。**

1. 算术表达式有可能产生未定义的结果，一部分原因是数学性质本身，例如除以0，另一部分源于计算机的特性，例如溢出，当计算的结果超出该类型所能表示的范围时就会溢出。

1. 整数相除结果还是整数，小数部分将被丢弃。例如21/6是3，21/7也是3。

1. 运算符%是取余或取模运算符。参与取余（%）运算的运算符必须是整数类型。

    ```c++
    int ival = 42;
    double dval = 3.14;
    ival % 12;   // 正确，结果是6。
    ival % dval; // 错误， dval是浮点型
    ```

1. **c++11新标准规定，商的值一律向0取整。**

1. 对于取模运算符（%）来说，如果 m % n 的运算结果不等于0，则它的符号与m相同。**而 (-m) / n 和 m / (-n) 都等于 -(m / n)，m % (-n) 等于 m % n，(-m) % n 等于 -(m % n)**。

    | 运算     | 结果 |
    | -------- | ---- |
    | 21 % 6   | 3    |
    | 21 % 7   | 0    |
    | -21 % -8 | -5   |
    | 21 % -5  | 1    |

## 4.3 逻辑和关系运算符

1. 逻辑运算符包含逻辑非（！）逻辑与（&&）逻辑或（||），关系运算符则包含大于小于等于不等于运算符（>, >=, <, <=, ==, !=），两者的返回类型都是布尔值，值为0的运算对象则为假，否则为真。对于这两类运算符来说，**运算对象和求值结果都是右值**。

1. 逻辑与（&&）和逻辑或（||）当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值，这种策略称为短路求值（short-circuit evaluation）:
   - 逻辑与：当且仅当左侧运算对象为真时才对右侧运算对象求值
   - 逻辑或：当且仅当左侧运算对象为假时才对右侧运算对象求值

1. 因为关系运算符的求值结果是布尔值，所以讲几个关系运算符连写在一起会产生意想不到的结果：

    ```c++
    if( i < j < k){
        // 此表达式会先返回i<j的结果，再用该结果和k作比较
        // 例如i<j为真返回1，则再用1<k来返回下一个结果
    }

    // 实际上我们想表达的是下式
    if( i < j && j < k){

    }
    ```

## 4.4 赋值运算符

1. 赋值运算符的左侧运算对象必须是一个可修改的左值。

    ```c++
    int i = 0, j = 0, k = 0;
    const int ci = i; // 这两行都是初始化，而非赋值
    1023 = k; // 错误，字面值是右值
    i + j = 
    k; // 错误， 算术表达式是右值
    ci = k; // 错误， ci是不可修改的常量左值
    ```

1. 赋值运算对象的结果是他的左侧运算对象，并且是一个左值。相应的，结果的类型就是左侧运算对象的类型。**如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。** C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。在这种情况下，**如果左值是一个内置类型，那么初始值列表最多只能包含一个值**，而且该值即使转换的话其所占空间也不应该大于目标类型的空间（比如不能赋值给一个short类型的值超过short的存储的范围）。

    ```c++
    k = {3.14}; // 错误，窄化转换
    vector<int> vi;
    vi = {0, 1, 2, 3}; // 正确，新标准允许这种赋值
    ```

1. 无论左侧运算对象的类型是什么，初始值列表都可以为空，此时，编译器创建一个值初始化的临时量并将其赋值给左侧对象。

1. **赋值运算符满足右结合律**：

    ```c++
    int i, j;
    i = j = 0; // 正确，i和j都被赋值为0。 0先被赋值给j，然后j赋值给i
    int *ptr;
    i = ptr = 0; // 错误，不能把int* 赋值给一个int对象

    double d;
    d = i = 3.5; // d是3.0, i是3
    i = d = 3.5; // d是3.5，i是3
    ```

1. 对于多重赋值语句中的每一个对象，它的类型或者与**右边对象的类型相同**、或者**可由右边对象的类型转换得到**。

1. 赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号：

    ```c++
    int i;
    while( (i = get_val()) != 31){ 
        // code block, 上方条件语句中如果不给赋值语句加上括号，
        // 那么将先判断get_val()和31然后返回布尔值赋值给i
    }
    ```

1. **切勿混淆相等运算符和赋值运算符！** if(i = j) 和 if(i = j)不同，后者是将j赋值给i然后转换成布尔值来进行判断

1. 任何一种符合运算符(+=, -=, \*=, /=, %=, >>=, <<=, &=, ^=, |=)都完全等价于 a = a *op* b。两者的唯一区别在于运算的次数，复合型只运算了一次，而常规运算操作则运算了两次（第一次对右边式子求值，第二次是赋值给左侧的对象）

## 4.5 递增和递减运算符

1. 递增和递减运算符有两种形式：前置版本（++i）和后置版本（i++）。**除非必须，否则不用递增递减的后置版本。**原因在于前置版本把值加1后直接返回并改变了对象，而后置版本则需要先将原始值存储下来，以用于返回这个未修改的值，在这种情况下，如果我们不需要原始值，那么将对内存是一种浪费。

    ```c++
    int i = 0, j;
    j = ++i; // 先对i进行加操作，在赋值给j
    j = i++; // 先保存i的原始值，再对i进行加操作，再把原始值赋值给j
    ```

1. 下面的代码中，++操作的优先级高于解引用（*），因此\*pbeg++等价于\*（pbeg++）。所以此处先对pbeg进行++操作，然后再返回其原始值给解引用操作符，此时解引用操作符返回的是pbeg未增加之前的值。此处可以有效避免解引用操作符操作一个先进行++再返回++之后的对象，因为此时对象可能已经指向一个未知的或不存在的元素，导致解引用发生不可预知的错误。

    ```c++
    cout << *iter++ << endl; // 习惯这种操作，更加简洁也更少出错

    cout << *iter << endl; // 尽量避免这种操作
    iter++;
    ```

1. 因为递增运算符和递减运算符会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。

    ```c++
    while(beg != s.end() && !isspace(*beg))
        *beg = toupper(*beg++); // 错误，赋值运算符两端的运算对象都用到了beg，
                                // 并且右侧的运算对象还改变了beg的值，此时无法知道先运算左边还是右边
                                // 所以该赋值语句是未定义的。

    if(vec[i++] <= vec[i]){
        // 同样地，此时也不能明确左右哪边先运算，也会导致该赋值是未定义的
    }
    ```

## 4.6 成员访问运算符

1. 解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两段必须加上括号，如果不加则含义大不相同：

    ```c++
    string s1 = "Hello", *p = &s1;
    auto n = s1.size();
    (*p).size(); // 先解引用p获取string对象，在调用size函数
    *p.size(); // 错误：p是一个指针，没有size成员函数
    ```

1. 箭头运算符作用于一个指针类型的运算对象，结果是一个左值。点运算符分两种情况：如果成员所属的对象是左值，那么结果是左值，反之如果成员所述的对象是右值，那么结果是右值。

1. 4.20例题，假设iter的类型是vector<string>::iterator,说明下面的表达式是否合法：

    ```c++
    *iter++; // 解引用操作优先级小于++，所以先保存值再加加再返回原来的值，合法
    (*iter)++; // 先解引用为string类型，再++，string++无意义，不合法
    *iter.empty(); // 解引用操作优先级小于点操作，先对iter进行empty成员函数，指针无该成员函数，不合法
    iter->empty(); // 合法
    ++*iter; // 先进行++，但++操作符操作于*iter解引用的string类型上，无意义，不合法
    iter++->empty(); // ++操作符优先级低于箭头操作符，先调用empty成员函数，再进行++，合法
    ```

## 4.7 条件运算符

1. 条件运算符的形式：cond ? expr1 : expr2   其中cond是判断条件的表达式，而expr1和expr2是两个类型相同或可能转换成某个公共类型的表达式。执行过程是：先求cond的值，如果条件为真再求expr1的值并返回，否则对expr2进行求值。

    ```c++
    string finalgrade = (grad < 60) ? "Fail" : "Pass";
    ```

1. 当条件运算符的两个表达式都是左值或者都能转换成同一种左值类型时，运算的结果是左值，否则运算结果为右值。

1. 条件运算符的内部允许嵌套另外一个条件运算符。

    ```c++
    string finalgrade = (grad < 60) ? "Fail" : (grad > 90) ? "High Pass" : "Pass";
    ```

1. 条件运算符满足右结合律，意味着运算对象（一般）按照从右向左的顺序组合。因此上述代码中，靠右边的条件运算（grad > 90）构成了左边的条件运算的分支。

1. 随着条件运算嵌套层数的增加，代码可读性急剧下降。所以最好不要超过三层嵌套。

1. 条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要再它两端加上括号。

    ```c++
    cout << ((grade < 60) ? "fail" : "pass"); // 输出pass或者fail
    cout << (grade < 60) ? "fail" : "pass"; // 输出0或者1,解释在下条
    cout << grade < 60 ? "fail" : "pass"; // 错误，试图比较cout和60
    ```

1. 上述第二个式子，grade和60的比较结果是<<运算符的运算对象，因此如果grade < 60，则输出1，否则输出0，之后返回的仍然是cout对象，接下来cout作为条件运算符的条件。因此该式子等价于：

    ```c++
    cout <<(grad <60); // 输出0或1
    cout ? "fail" : "pass"; // 根据cout是true还是false产生相应的字面值
    ```

1. 第三个表达式则等价于：

    ```c++
    cout << grade;
    cout < 60 ? "fail" : "pass"; // 此处比较cout和60,此处为错误
    ```

## 4.8 位运算符

1. 位运算符作用于整数类型的运算对象，并把运算对象看做是二进制的集合。位运算符提供检查和设置二进制位的功能。标准库提供了一个名为bitset的标准库类型，可以表示任意大小的二进制位集合。所以位运算符同样能用于bitset类型。

1. 位运算符符合左结合律：

    | 运算符 | 功能   | 用法           |
    | ------ | ------ | -------------- |
    | -      | 位求反 | -expr          |
    | <<     | 左移   | expr1 << expr2 |
    | >>     | 右移   | expr1 >> expr2 |
    | &      | 位与   | expr & expr    |
    | ^      | 位异或 | expr ^ expr    |
    | \|     | 位或   | expr ^ expr    |

1. 一般来说，如果运算对象是“小整型”，则他的值会被自动提升成较大的整数类型。**注意：如果运算对象是带符号的且他的值是为负，那么位运算符号如何处理运算对象的“符号位”依赖于机器。而且，此时左移操作可能会改变符号位的值，因此是一种未定义的行为。所以强烈建议仅将位运算符用于处理无符号类型。**

1. 移位运算符（<<和>>）的内置含义是对其运算对象执行基于二进制的位移动操作。首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。二进制位或者向左移或者向右移，移出边界之外的位就会被舍弃掉了。

    ```c++
    unsigned char bits = 0233; // 10011011
    bits << 8; // bits提升成了int型，然后左移8位
            // 00000000 00000000 10011011 00000000
    bits << 31; // 左移31位，左边超出边界的位丢弃掉了
                // 10000000 00000000 00000000 00000000
    bits >> 3; // 向右移动3位，最右边的3位丢弃掉了
                // 00000000 00000000 00000000 00010011
    ```

1. **左移运算符在右侧插入值为0的二进制位。右移运算符则依赖于运算对象的类型：如果是无符号类型，则在左侧插入0的二进制位，如果是带符号，则左侧插入符号位的副本或值为0的二进制。具体视环境而定。**

1. 位求反(~)则是将运算对象逐位求反。

   ```c++
   unsigned char bits = 0227; // 10010111
   ~bits; //先在前面加0提升为int型，再依次求反。
          // 00000000 00000000 00000000 10010111 提升为int
          // 11111111 11111111 11111111 01101000 依次求反
    ```

1. 位操作
   - '&’：通常将某些位清0且同时保持其他位不变

    ```c++
    int n = 5;
    n = n & 0xffffff00 //将n的低八位重置为0
    ```

   - '|': 通常将某些位变成1且同时保持其他位不变

    ```c++
    int n = 5;
    n = n | 0xffffff00 //将n的低八位重置为1
    ```

    - '^':异或操作，只有**相同时为0，否则为1**，用于变量中某些位的取反

    ```c++
    int n = 5;
    n = n ^ 0xff //将n的低八位取反
    ```

    - '>>'：左移运算符，高位丢弃低位补0.左移一位相当于乘以2，左移n位相当于乘以$2^n$。**左移方法比乘法操作更快！！**

    - '<<':原符号为0则右移高位补0，原符号为1则右移高位补1。右移操作n位相当于除以$2^n$并将结果向小一个数取整。
        例如：<br/>$-25 >> 4 = -25 / 2^4 = -2$<br/>$18 >> 4 = 18 / 2^4 = 1$

1. 异或操作的实际应用：数据交换。如果 a^b = c, 那么 b^c = a, a^c = b

    ```c++
    int a = 1, b = 2;
    a = a^b;
    b = b^a;
    a = a^b;// a和b的值互换
    ```

1. 位移操作符满足左结合律，它们的重载版本可以进行IO操作。位移操作的优先级不高不低，介于中间：比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高。因此在一次使用多个运算符时，有必要适当的地方加上括号使其满足我们的要求。

    ```c++
    cout << 42 + 10; // 正确，+优先级更高，因此输出求和的结果
    cout << (10 < 42); // 正确，括号使得运算对象按照我们的期望组合在一起，输出1
    cout << 10 < 42; // 错误：试图比较cout对象和42的大小
    ```

1. 例题4.27：

    ```c++
    unsigned long ull = 3, ul2 = 7;
    ull & ul2; // 3
    ull | ul2; // 7
    ull && ul2; // 1
    ul1 || ul2; // 1
    ```

## 4.9 sizeof运算符

1. sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。

1. 运算符的运算对象有两种形式：
   - sizeof(type)
   - suzeif expr

1. 在上述第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值：

    ```c++
    Sales_data data, *p;
    sizeof(Sales_data); // 存储Sales_data类型的对象所占的空间大小
    sizeof data;// data的类型的大小，即sizeof(Sales_data)
    sizeof p; //指针所占空间大小
    sizeof *p; // p所指类型的空间大小，即sizeof(Sales_data)
    sizeof data.revenue; // revenue成员所对应的大小
    sizeof Sales_data::revenue; // 另一种获取revenue大小的方式
    ```

1. 上述例子中最有意思的是sizeof *p，首先因为sizeof满足右结合律并且与\*的运算符的优先级一样，所以表达式按照从右向左的顺序组合。也就是说，他等价于sizeof(*p)。其次，因为sizeof不会实际求运算对象的值，所以即使p是一个无效的（未初始化的）指针，也不会有什么影响。在sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正的使用。sizeof不需要真的解引用指针也能知道他所指对象的类型。

1. c++11新标准允许我们使用作用域运算来获取类成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无须我们提供一个具体的对象，因为要想知道类成员的大小无须真的获取该成员。