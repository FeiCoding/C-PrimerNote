# chapter 4 表达式

## 4.1 基础

1. 作用于一个运算对象的运算符是一元运算符，如取地址符（&）和解引用符（\*），作用域两个运算对象的运算符是二元运算符，如相等运算符（==）和乘法运算符（\*）,还有作用域三个运算对象的三元运算符。函数电泳也是一种特殊的运算符，它对运算对象的数量没有限制。

1. 一些符号既能作为一元运算符也能作为二元运算符，比如*号既可以是解引用，也可以是乘号。

1. 即使运算对象的类型不同，只要他们能被转换，也能使用二元运算符进行计算。例如整数变成浮点数，浮点数转换成整数。**小整数类型（如bool、char、short等）通常会被提升成较大的整数类型，主要是int。**

1. C++表达式要不然是右值（rvalue）要不然就是左值（lvalue），左值可以位于赋值语句的左边，而右值不能。在C++中，一个左值表达式的求值结果是一个对象或者一个函数，而以常量对象为代表的某些左值并不能作为赋值语句的左侧运算对象。**归纳：当一个对象被用作右值时，用的是对象的值（内容），而当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。**[详解博客](https://www.cnblogs.com/catch/p/3500678.html)

1. **一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）来使用。当一个左值被当成右值使用时，实际使用是他的内容（值）。**

1. 以下是一些我们常用的需要用到左值的运算符：
    - 赋值运算符需要有个（非常量）左值作为其左侧运算对象，得到的结果也仍然是一个左值。
    - 取地址符（&）作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。
    - 内置引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值。
    - 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值

1. 使用关键字decltype的时候，如果表达式的求值结果是左值，则得到一个引用类型（例如decltype(*p)返回的是一个引用 int&），如果取地址运算符生成右值，例如decltype(&p)，那么会返回一个int**，也就是一个指向整形指针的指针。

1. 表达式中的括号无视运算符的优先级。程序员可以使用括号将某个表达式的某个局部括起来使其得到优先运算。

1. 算术运算符满足结合律，也就是当运算符的优先级相同，将按照从左向右的顺序组合运算对象

1. 对于没有指定执行顺序的运算符来说，**如果表达式指向并修改了同一个对象**，将会引发错误并产生未定义的行为。例如：

    ```c++
    int i = 0;
    cout << i << " " << i++ << endl; // 未定义的
    // 因为程序可能先执行i++再执行i，也可能先执行i再求i++，因此结果产生了不可预知性
    ```

1. 有4种运算符明确规定了运算对象的求值顺序。分别是 '&&' ， '||' ， '？：' ， ','这4种

1. 对于表达式的结合律例如f() + g() * h() + j()的表达式中，如果f\g\h\j是无关函数，他们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制，反之，如果其中某几个函数影响同一对象，则他是一条错误的表达式

## 4.2 算数运算符
1. 算术运算符的优先级（由上至下优先级降低）：

    | 运算符 | 功能     | 用法        |
    |------ | -------- | ----------- |
    | +      | 一元正号 | + expr      |
    | -      | 一元负号 | - expr      |
    | *      | 乘法     | expr * expr |
    | /      | 除法     | expr / expr |
    | %      | 求余     | expr % expr |
    | +      | 加法     | expr + expr |
    | -      | 减法     | expr - expr |

1. 算术运算符能作用于任意算术类型以及任意能转换成为算术类型的类型，算术运算符的运算对象和求值结果都是右值。在表达式求值之前，小整数类型的运算对象被提升为较大整数类型，所有运算对象最终都会转换成同一类型。

1. 一元正号运算符、加法运算符和减法运算符都能作用于指针。当**一元正号**运算符作用于一个指针或算数值时，返回运算对象值的一个（提升后的）副本。一元负号运算符对运算对象值取负后，返回其（提升后的）副本：

    ```c++
    int i = 1024;
    int k = -i; // k是-1024
    bool b = true;
    bool b2 = -b; // b2是true！！
    ```

1. **上述布尔值b2先被转换成int型1，然后加上‘-’号后变为-1，然后再转换成布尔值则为1（布尔值只有在0的时候为false），所以尽量避免在运算中使用布尔值。**

1. 算术表达式有可能产生未定义的结果，一部分原因是数学性质本身，例如除以0，另一部分源于计算机的特性，例如溢出，当计算的结果超出该类型所能表示的范围时就会溢出。

1. 整数相除结果还是整数，小数部分将被丢弃。例如21/6是3，21/7也是3。

1. 运算符%是取余或取模运算符。参与取余（%）运算的运算符必须是整数类型。

    ```c++
    int ival = 42;
    double dval = 3.14;
    ival % 12;   // 正确，结果是6。
    ival % dval; // 错误， dval是浮点型
    ```

1. **c++11新标准规定，商的值一律向0取整。**

1. 对于取模运算符（%）来说，如果m%n的运算结果不等于0，则它的符号与m相同。**而(-m)/n和m/(-n)都等于-(m/n),m%(-n)等于m%n，(-m)%n等于-(m%n)**。

## 4.3 逻辑和关系运算符

1. 