# chapter 7 类

## 7.1 定义抽象数据类型

### 7.1.1 类的概念

1. 类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程技术。类的接口包括用户所能执行的操作，类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

1. 封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。

1. 类要想实现数据抽象和封装，需要首先定义一个抽象数据类型（abstract data type）。在抽象数据类型中，由类的设计者负责考虑类的实现过程，使用该类的程序员则只需要抽象的思考类型做了什么，而无需了解类型的工作细节。

### 7.1.2 类的成员函数

1. 定义和声明成员函数的方式与普通函数差不多。成员函数的声明必须在类的内部，它的定义则既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数，他们的定义和声明都在类的外部。

1. 定义在类的内部的函数是隐式的inline函数。

### 7.1.3 this关键字

1. 成员函数可以通过this这样一个额外的隐式参数来访问调用它的那个对象。当我们用一个成员函数时，用请求该函数的对象地址初始化this。例如当我们调用total.isbn()，则编译器负责把total的地址传给isbn的隐式形参this，可以等价的认为编译器将该调用重写成了Sales_data::isbn(&total)其中，调用sales_data的isbn成员时传入了total的地址。

1. 实际上在成员函数内部我们可以直接使用该函数的对象的成员而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。

1. 任何对类成员的直接访问都被看做this的隐式引用，也就是说，当isbn使用bookNo时，它隐式的使用this指向的成员，就像我们书写this->bookNo一样。

1. 任何自定义名为this的参数或变量的行为都是非法的。

1. 因为this的目的总是指向“这个”对象，所以this是一个常量指针（*const），我们不允许改变this中保存的地址。

### 7.1.3 const成员函数

1. 紧随参数列表之后的const关键字，作用是修改隐式this指针的类型，将this变为指向const的指针（而且this自身还是一个常量指针，所以此时this就是指向常量的常量指针）。

    ```c++
    std::string isbn() const { return bookNo; }
    ```

1. 常量对象不可以被一个非指向常量的指针绑定。所以当我们想要让this指针既能指向常量对象，又能指向非常量对象，我们就应该将其声明成一个指向常量的指针，但是this是一个隐式声明的指针，此时C++允许我们在函数的参数列表后面加上const来把this声明成一个指向const的指针，同时也表明了isbn这个函数的内部无法改变对象的值。

1. 像上述这样声明的const的成员函数被称作常量成员函数（const member function）

1. 常量对象，以及常量对象的引用或指针只能调用常量成员函数。

1. 由于编译器分两步处理类：先编译成员的声明，然后才轮到成员函数体。因此成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。（上述代码中，即便先定义函数isbn再定义变量bookNo依然可以编译。）

1. 当我们在类的外部定义成员函数时，成员函数的定义必须与他的声明匹配。也就是说，返回的类型、参数列表和函数名都得与类内部的声明保持一致。如果成员函数被声明成常量成员函数，那么他的定义也必须在参数列表后明确指定const属性。

    ```c++
    double Sales_data::avg_price() const{
        if(units_sold)
            return revenue/units_sold;
        else
            return 0;
    }
    ```

### 7.1.3 自定义IO成员函数

1. 一般来说，当我们定义的函数类似于某个内置运算符时，应该令该函数的行为尽量模仿这个运算符。内置的运算符把它的左侧运算对象当成左值返回，因此当我们模仿此类函数时也应当返回一个引用类型（只有返回引用类型时才是左值）。

    ```c++
    Sales_data& Sales_data::combine(const Sales_data &rhs){
        units_sold += rhs.units_sold;
        revenue += rhs.revenue;
        return *this; // 解引用this返回调用该函数的对象
    }
    ```

1. 类的坐着常常需要定义一些辅助函数，比如add、read和print等。尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但他们实际上并不属于类本身。

1. 如果函数在概念上属于类但是不定义在类中，则一般他们应与类声明（而非定义）在同一个头文件中。

1. 如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一头文件内。

1. 下面代码定义了read和print函数，比较重要的一点是，read和print分别接收一个各自IO类型的引用作为其参数，这是因为**IO类属于不能被拷贝的类型**，因此我们只能通过引用来传递他们。而且因为**读取和写入的操作会改变留的内容，所以两个函数接收的都是普通引用，而非对常量的引用**。

    ```c++
    istream &read(istream &is, Sales_data &item){
        double price = 0;
        is >> item.bookNo >> item.units_sold >> price;
        item.revenue = price * item.units_sold;
        return is;
    }
    
    //将Sales_data对象定义成const，原因是无须改变对象的内容
    ostream &print(ostream &os, const Sales_data &item){
        os << item.isin() << " " << item.units_sold << " "
            << item.revenue << " " << item.avg_price();

        return  os;
    }
    ```

1. 此处的print函数一般不负责换行，一般来说，执行输出任务的函数应尽量减少对格式的控制，这样可以确保由用户代码来决定是否换行。

### 7.1.4 构造函数

1. 构造函数（constructor）的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

1. 构造函数的名字和类相同，没有返回类型。类可以包含多个构造函数，但是每个构造函数必须在参数数量或参数类型上有所区别。构造函数不能被声明成const。构造函数在const对象的构造过程中可以向其写值。

1. 类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫默认构造函数（default constructor）。默认构造函数无须任何实参。

1. 编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）。该构造函数将按如下规则初始化类的数据成员：
    - 如果存在类内初始值，用它来初始化成员。
    - 否则，默认初始化该成员。

1. 