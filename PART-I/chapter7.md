# chapter 7 类

## 7.1 定义抽象数据类型

### 7.1.1 类的概念

1. 类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程技术。类的接口包括用户所能执行的操作，类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

1. 封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。

1. 类要想实现数据抽象和封装，需要首先定义一个抽象数据类型（abstract data type）。在抽象数据类型中，由类的设计者负责考虑类的实现过程，使用该类的程序员则只需要抽象的思考类型做了什么，而无需了解类型的工作细节。

### 7.1.2 类的成员函数

1. 定义和声明成员函数的方式与普通函数差不多。成员函数的声明必须在类的内部，它的定义则既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数，他们的定义和声明都在类的外部。

1. 定义在类的内部的函数是隐式的inline函数。

### 7.1.3 this关键字

1. 成员函数可以通过this这样一个额外的隐式参数来访问调用它的那个对象。当我们用一个成员函数时，用请求该函数的对象地址初始化this。例如当我们调用total.isbn()，则编译器负责把total的地址传给isbn的隐式形参this，可以等价的认为编译器将该调用重写成了Sales_data::isbn(&total)其中，调用sales_data的isbn成员时传入了total的地址。

1. 实际上在成员函数内部我们可以直接使用该函数的对象的成员而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。

1. 任何对类成员的直接访问都被看做this的隐式引用，也就是说，当isbn使用bookNo时，它隐式的使用this指向的成员，就像我们书写this->bookNo一样。

1. 任何自定义名为this的参数或变量的行为都是非法的。

1. 因为this的目的总是指向“这个”对象，所以this是一个常量指针（*const），我们不允许改变this中保存的地址。

### 7.1.3 const成员函数

1. 紧随参数列表之后的const关键字，作用是修改隐式this指针的类型，将this变为指向const的指针（而且this自身还是一个常量指针，所以此时this就是指向常量的常量指针）。

    ```c++
    std::string isbn() const { return bookNo; }
    ```

1. 常量对象不可以被一个非指向常量的指针绑定。所以当我们想要让this指针既能指向常量对象，又能指向非常量对象，我们就应该将其声明成一个指向常量的指针，但是this是一个隐式声明的指针，此时C++允许我们在函数的参数列表后面加上const来把this声明成一个指向const的指针，同时也表明了isbn这个函数的内部无法改变对象的值。

1. 像上述这样声明的const的成员函数被称作常量成员函数（const member function）

1. 常量对象，以及常量对象的引用或指针只能调用常量成员函数。

1. 由于编译器分两步处理类：先编译成员的声明，然后才轮到成员函数体。因此成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。（上述代码中，即便先定义函数isbn再定义变量bookNo依然可以编译。）

1. 当我们在类的外部定义成员函数时，成员函数的定义必须与他的声明匹配。也就是说，返回的类型、参数列表和函数名都得与类内部的声明保持一致。如果成员函数被声明成常量成员函数，那么他的定义也必须在参数列表后明确指定const属性。

    ```c++
    double Sales_data::avg_price() const{
        if(units_sold)
            return revenue/units_sold;
        else
            return 0;
    }
    ```

### 7.1.3 自定义IO成员函数

1. 一般来说，当我们定义的函数类似于某个内置运算符时，应该令该函数的行为尽量模仿这个运算符。内置的运算符把它的左侧运算对象当成左值返回，因此当我们模仿此类函数时也应当返回一个引用类型（只有返回引用类型时才是左值）。

    ```c++
    Sales_data& Sales_data::combine(const Sales_data &rhs){
        units_sold += rhs.units_sold;
        revenue += rhs.revenue;
        return *this; // 解引用this返回调用该函数的对象
    }
    ```

1. 类的坐着常常需要定义一些辅助函数，比如add、read和print等。尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但他们实际上并不属于类本身。

1. 如果函数在概念上属于类但是不定义在类中，则一般他们应与类声明（而非定义）在同一个头文件中。

1. 如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一头文件内。

1. 下面代码定义了read和print函数，比较重要的一点是，read和print分别接收一个各自IO类型的引用作为其参数，这是因为**IO类属于不能被拷贝的类型**，因此我们只能通过引用来传递他们。而且因为**读取和写入的操作会改变留的内容，所以两个函数接收的都是普通引用，而非对常量的引用**。

    ```c++
    istream &read(istream &is, Sales_data &item){
        double price = 0;
        is >> item.bookNo >> item.units_sold >> price;
        item.revenue = price * item.units_sold;
        return is;
    }
    
    //将Sales_data对象定义成const，原因是无须改变对象的内容
    ostream &print(ostream &os, const Sales_data &item){
        os << item.isin() << " " << item.units_sold << " "
            << item.revenue << " " << item.avg_price();

        return  os;
    }
    ```

1. 此处的print函数一般不负责换行，一般来说，执行输出任务的函数应尽量减少对格式的控制，这样可以确保由用户代码来决定是否换行。

### 7.1.4 构造函数

1. 构造函数（constructor）的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

1. 构造函数的名字和类相同，没有返回类型。类可以包含多个构造函数，但是每个构造函数必须在参数数量或参数类型上有所区别。构造函数不能被声明成const。构造函数在const对象的构造过程中可以向其写值。

1. 类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫默认构造函数（default constructor）。默认构造函数无须任何实参。

1. 编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）。该构造函数将按如下规则初始化类的数据成员：
    - 如果存在类内初始值，用它来初始化成员。
    - 否则，默认初始化该成员。

1. 只有当类没有声明任何构造函数时编译器才会默认生成构造函数。一旦我们定义了其他构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。

1. 如果定义在块中的内置类型或复合类型（数组、指针等）的对象被编译器默认初始化将出现未定义的值。所以当我们使用内置类型或复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。

1. 如果类中包含了其他的类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的类来说，我们必须自定义默认构造函数，否则该类将没有可用的默认构造函数。

1. 定义默认构造函数，我们可以使用C++11新标准中，通过在参数列表后面写上=default来要求编译器生成构造函数。=default既可以声明在类内部（那么就是内联的），也可以声明在类外部（非内联）。

    ```c++
    Sales_data() = default;
    ```

1. 构造函数初始值列表（constructor initialize list），他负责为新创建的对象的一个或几个数据成员赋初始值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号起来的（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。

    ```c++
    Sales_data(const std::string &s):bookNo(s){ }
    Sales_data(const std::string &s, unsigned n, double p):
        bookNo(s),units_sold(n), revenue(p*n){ }
    ```

1. 当某个数据成员被构造函数初始值列表忽略时，他将以与合成默认构造函数相同的方式隐式初始化。此时我们可以将其进行类内初始值初始化(在类中直接用一个值声明定义变量)，因此只接受一个string参数的构造函数等价于下列代码：

    ```c++
    Sales_data(const std::string &s):
        bookNo(s), units_sold(0), revenue(0){ }
    ```

1. 构造函数不应轻易覆盖掉类内初始值，除非新赋的值与原值不同。如果不能使用类内初始值，则所有构造函数都应该显式的初始化每个内置类型的成员。

1. 很多需要动态内存的类能而且应该使用vector对象或者string对象管理必要的存储空间。使用vector或者string的类能便面分配和释放内存带来的复杂性。原因在于当我们对含有vector成员的对象执行拷贝或赋值操作时，vector类会设法拷贝或者赋值成员中的元素。当这样的对象被销毁时，将销毁vector对象，也就是依次销毁vector中的每一个元素。（string也是如此）

## 7.2 访问能控制与封装

### 7.2.1 访问说明符
1. 我们使用访问说明符（access specifiers）加强类的封装性：
    - 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口
    - 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（即隐藏了）类的实现细节。

1. 对于一个类可以出现0或多个访问说明符，对于某个访问限定符能出现多少次没有严格的规定，每个访问说明符制定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾为止。

1. struct和class的唯一区别是他们的默认访问权限不一样。如果我们使用struct，则默认访问符是public，而class则是private。

1. 我们希望定义的类的所有成员是public的时候使用struct，反之则使用class。

### 7.2.2 友元

1. 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend），此时只需要添加一条以friend关键字开始的函数声明即可。

1. 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限，一般来说我们需要在类的定义开始或结束前的位置集中声明友元，友元不是类的成员也不受它所在区域访问控制级别的约束。

1. 封装的益处：
   - 确保用户代码不会无意间破坏封装对象的状态
   - 封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。

1. 为了使友元