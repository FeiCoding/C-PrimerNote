# chapter 7 类

1. 类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程技术。类的接口包括用户所能执行的操作，类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

1. 封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。

1. 类要想实现数据抽象和封装，需要首先定义一个抽象数据类型（abstract data type）。在抽象数据类型中，由类的设计者负责考虑类的实现过程，使用该类的程序员则只需要抽象的思考类型做了什么，而无需了解类型的工作细节。

1. 定义和声明成员函数的方式与普通函数差不多。成员函数的声明必须在类的内部，它的定义则既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数，他们的定义和声明都在类的外部。

1. 定义在类的内部的函数是隐式的inline函数。

1. 成员函数可以通过this这样一个额外的隐式参数来访问调用它的那个对象。当我们用一个成员函数时，用请求该函数的对象地址初始化this。例如当我们调用total.isbn()，则编译器负责把total的地址传给isbn的隐式形参this，可以等价的认为编译器将该调用重写成了Sales_data::isbn(&total)其中，调用sales_data的isbn成员时传入了total的地址。

1. 实际上在成员函数内部我们可以直接使用该函数的对象的成员而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。

1. 任何对类成员的直接访问都被看做this的隐式引用，也就是说，当isbn使用bookNo时，它隐式的使用this指向的成员，就像我们书写this->bookNo一样。

1. 任何自定义名为this的参数或变量的行为都是非法的。

1. 因为this的目的总是指向“这个”对象，所以this是一个常量指针（*const），我们不允许改变this中保存的地址。

1. 紧随参数列表之后的const关键字，作用是修改隐式this指针的类型，将this变为指向const的指针（而且this自身还是一个常量指针，所以此时this就是指向常量的常量指针）。

    ```c++
    std::string isbn() const { return bookNo; }
    ```

1. 常量对象不可以被一个非指向常量的指针绑定。所以当我们想要让this指针既能指向常量对象，又能指向非常量对象，我们就应该将其声明成一个指向常量的指针，但是this是一个隐式声明的指针，此时C++允许我们在函数的参数列表后面加上const来把this声明成一个指向const的指针，同时也表明了isbn这个函数的内部无法改变对象的值。

1. 像上述这样声明的const的成员函数被称作常量成员函数（const member function）

1. 常量对象，以及常量对象的引用或指针只能调用常量成员函数。

1. 由于编译器分两步处理类：先编译成员的声明，然后才轮到成员函数体。因此成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。（上述代码中，即便先定义函数isbn再定义变量bookNo依然可以编译。）

1. 当我们再类的外部定义成员函数时，成员函数的定义必须与他的声明匹配。也就是说，返回的类型、参数列表和函数名都得与类内部的声明保持一致。如果成员函数被声明成常量成员函数，那么他的定义也必须在参数列表后明确指定const属性。

    ```c++
    double Sales_data::avg_price() const{
        if(units_sold)
            return revenue/units_sold;
        else
            return 0;
    }
    ```

1. 