# chapter 6 函数

## 6.1 函数基础

1. 一个典型的函数定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。

1. return语句完成两项任务：一是返回return语句中的值，而是将控制权从被调函数转移回主调函数。

1. 实参的类型必须与形参额类型相匹配。函数有几个形参，我们就必须提供相同数量的实参。

1. 参数传递允许形参是实参可转换的类型

    ```c++
    double fact(double i){
        return i;
    }
    int d = 1;
    fact(d); // 可以，int可以转换成double
    ```

1. 函数的形参列表可以为空。但是不能省略。为了与c语言兼容，也可以使用关键字void表示函数没有形参。

    ```c++
    void f1(){ } // 隐式的定义空形参列表
    void f2(void){ } // 显式的定义空形参列表
    ```

1. **形参列表中所有的参数类型都必须写出来，几遍类型相同。任意两个形参的名称都不可以相同。函数最外层作用域的局部变量也不能喝函数形参一样的名字。**

1. 函数的返回值不能是数组类型或者函数类型，但可以是指向数组或函数的指针。

1. 形参和函数体内部定义的变量统称为局部变量（loacl variable）他们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏（hide）在外部同名的其他所有声明中。在所有函数体之外定义的对象存在于程序的整个执行过程。此类对象在程序启动时被创建，知道程序结束才会销毁。

1. 我们把只存在于块执行期间的对象称为自动对象（automatic object），当块的执行结束后，块中创建的自动对象的值就变成未定义的了。形参是一种自动对象，函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，所以一旦函数终止，形参也就被销毁了。

1. 形参初始化的三种方式：
   - 传递给参数的实参初始化形参对应的自动对象
   - 变量本身含有初始值
   - 本身不含有初始值，则执行默认初始化，这意味着内置类型的未初始化局部变量将产生未定义的值。

1. 当有必要令局部变量的生命周期贯穿函数调用及之后的时间，可以将局部变量定义成static类型从而获得这样的对象。局部静态对象（loacl static object）在程序的执行路径第一次经过对象定义语句时初始化 ，并指导程序终止才被销毁。在此期间即使对象所在的函数结束执行也不会对它有影响。

    ```c++
    size_t count_calls(){
        static size_t c = 0;
        return c++； // 可以return这个局部变量，因为它是static
        // 如果c不是static将报错
    }
    int main(){
        for(size_t i = 0; i != 10;++i){
            cout << count_calls() << endl;
        }
        return 0;
    }
    ```

1. **如果局部静态变量没有显示初始值，他将执行值初始化，内置类型的局部静态变量初始化为0**

1. 与变量类似，函数只能定义一次，但可以声明多次，唯一的例外是如果一个函数永远也不会被我们用到，那么它可以只有声明没有定义。

1. 函数声明（也称函数原型function prototype）无须函数体，用一个分号代替即可，同时也无须形参的名字。然而写上形参的名字可以帮助使用者更好的理解函数的功能。

    ```c++
    // 函数声明加上名字beg和end使我们更好地理解函数的功能
    void print(vector<int>::const_iterator beg,
                vector<int>::const_iterator end);
    ```

1. **函数也应该在头文件中声明，在原文件中定义。把函数放在头文件中声明，就能确保同一函数的所有声明保持一致，而且一旦我们想改变函数的接口，只需改变一条声明即可。含有函数生命的头文件，应当被包含到含有函数定义的源文件中**

## 6.2 参数传递

1. 形参的类型决定了形参和实参交互的方式。如果形参是引用类型，他将被绑定到对应的实参上（引用传递passed by reference），否则，将实参的值拷贝给形参（值传递passed by value）。

1. 对于指针形参，当执行指针拷贝操作时，拷贝的是指针的值，拷贝之后，两个指针是不同的指针。下面的代码中，指针形参可以改变实参的值，但无法改变实参的地址。

    ```c++
    void reset(int *p){
        *p = 0; //改变了p所指对象的值
        p = 0; // 只改变了p的局部拷贝，实参无影响
    }
    int main(){
        int i = 42;
        reset(&i); // i的值被改变，但i的地址未被改变
        cout << i << end; // 输出0
    }
    ```

1. 通过使用引用形参，允许函数改变一个或多个实参的值。引用形参绑定初始化它的对象，改变引用形参也就是改变其引用对象的值。

1. 尽量使用引用形参而避免拷贝，因为拷贝某些大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO）就不支持拷贝操作。此时我们也只能使用引用形参。

1. **当函数无须改变引用形参的值时，最好将其声明为常量引用。**

1. 我们可以给函数传入一个额外的引用实参，令其保存我们想要的变量，从而实现让函数返回额外的信息。

    ```c++
    string::size_type find_char(const string &s, char c, string::size_type &occurs){
        auto ret = s.size();
        occurs = 0;
        for(decltype(ret) i = 0; i != s.size(); ++i){
            if(s[i] == c){
                if(ret == s.size())
                    ret = i; // 记录第一次出现的位置
                ++occurs; // 将出现次数加一
            }
        }
        return ret; // 出现次数通过occurs隐式的返回
    }
    ```

1. 当实参初始化形参时会忽略掉形参的顶层const，也就是说当形参有顶层const时，传给他常量对象或非常量对象都是可以的。

1. 因为顶层const被忽略掉，所以对于相同名字的函数，形参表中的const不能区分这些函数，导致重复定义（而非函数重载）。

    ```c++
    void func(int i);
    void func(const int i); // 重复定义
    ```

1. 把函数不会改变的形参定义成普通引用是一种比较常见的错误，这么做带给函数调用者一种误导，即函数可以修改他的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。例如，我们不能把const对象、字面值或者需要类型转换的对象、传递给普通的引用形参。

    ```c++
    string::size_type find_char(string &s, char c, string::size_type &occurs){
        // string &s是一个不良设计，因为此时find_char（“Hello World", 'o', ctr)将会报错
    }
    ```

1. 