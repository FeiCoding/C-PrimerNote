# Important Review Point

## chapter 2

1. 取模定义

   > 对于整数a，b来说，取模运算或者求余运算的方法要分如下两步：  
   > 1.求整数商：c=a/b  
   > 2.计算模或者余数：r=a-(c*b)  
   > 求模运算和求余运算在第一步不同  
   > 取余运算在计算商值向0方向舍弃小数位  
   > 取模运算在计算商值向负无穷方向舍弃小数位  
   > 例如：4/\(-3\)约等于-1.3  
   > 在取余运算时候商值向0方向舍弃小数位为-1  
   > 在取模运算时商值向负无穷方向舍弃小数位为-2  
   > 所以  
   > 4rem\(-3\)=1  
   > 4mod\(-3\)=-2

1. 当使用列表初始化且初始值存在丢失信息的风险，编译器会报错。

1. 函数内部如果初始化一个extern关键字标记的变量将引发错误（不能在函数体内使用extern）

1. c++标志符：
   * 必须以字母或下划线开头（定义在函数体外的标识符不能以下划线开头）
   * 对大小写敏感
   * 不能使用c++保留字
   * 不能连续出现两个下划线
   * 不能以下划线连接大写字母开头

1. 我们不能直接操作void\*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也无法知道在这个对象上做哪些操作

1. 大部分情况下所有引用类型都必须和与之绑定的对象严格匹配，**引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。**

1. 指针的类型都要和他所指的对象严格匹配。

1. 如果用一个对象**去初始化另一个对象**，则他们**是不是const都无关紧要(只有顶层const会被忽略)** 

1. 如果想在多个文件之间共享const对象，则必须在变量的定义之前添加extern关键字

1. 常量对象只能用常量引用来引用它,而不能使用一般引用

1. **constexpr只能将指针声明成const，而对该指针指向的对象无影响**。(也就是说constexpr是定义一个顶层const)，此时constexpr指针既可以指向常量又可以指向非常量。

    ```cpp
     const int *ptr = nullptr; // 指向常量的指针
     constexpr int *ptr2 = nullptr; // 常量指针，指针本身是常量
    ```

1. auto类型说明符，能让编译器代替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型，所以**auto定义的变量必须有初始值**。

1. auto会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时。

1. 如果希望推断出的auto类型是一个顶层const，必须在前面加上const（const auto）

1. 使用引用实际是初始化引用对象的值，因此编译器会以引用对象的类型作为auto类型。如果想将引用的类型设置为auto，则在变量之前加上& (auto &i = a)

1. decltype处理顶层const和引用的方式与auto不同，decltype会返回变量的类型包括顶层const和引用在内

1. decltype和auto的区别：
   * 处理顶层const和引用的方式不同，auto会忽略顶层const，对于引用返回引用对象类型，而decltype不会忽视，对于引用直接返回引用类型）
   * decltype直接跟上变量则直接返回变量类型，如果decltype加上一或多层括号则会将该变量视为表达式（**decltype的双括号结果永远视为引用**）

     ```cpp
       int i = 1;
       decltype((i)) d; // 双括号，类型为int&
       decltype(i) e; // 类型为int
     ```

## chapter 3

1. string 的成员函数 size()返回的并不是一个 int 或 unsigned，而是 string::size_type 类型的值。size_type 是一种无符号类型的值而且能足够存放下任何 string 对象的大小。所有用于存放 string 类的 size 函数返回值的变量，都应该是 string::size_type 类型的。

1. 由于 size 函数返回的是一个无符号整型数，所以此时如果混用带符号的类型数可能会产生意想不到的后果。

1. 数组维度说明了数组中元素的个数，因此必须大于 0，数组元素的个数也属于数组类型的一部分，编译的时候维度应该是一致的，也就是说，**维度必须是一个常量表达式**：

1. 字符数组的特殊性：使用**字符串字面值**来初始化字符数组时，一定要注意字符串字面值的结尾处还有一个空字符。

   ```cpp
    char a1[] = {'c', '+', '+'}; // 列表初始化，没有空字符
    char a2[] = {'c', '+', '+', '\0'}; // 列表初始化，含有显示的空字符
    char a3[] = "c++"; // 自动添加字符串结束的空字符
    char a4[5] = "Hello"; // 错误，应当设置维度为6来存放额外的‘\0’
   ```

1. 使用数组的时候，编译器一般会把它转换成指针。**当使用数组作为一个 auto 变量的初始值时，推断得到的类型是指针而非数组。**

## chapter 4

1. **一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）来使用。当一个左值被当成右值使用时，实际使用是他的内容（值）。**

1. 使用关键字decltype的时候，如果表达式的求值结果是左值，则得到一个引用类型（假设p是int\*类型，decltype(\*p)返回的是一个引用 int&），如果取地址运算符生成右值，例如decltype(&p)，那么会返回一个int\*\*，也就是一个指向整形指针的指针。

1. 算术运算符能作用于任意算术类型以及任意能转换成为算术类型的类型，**算术运算符的运算对象和求值结果都是右值**。在表达式求值之前，小整数类型的运算对象被提升为较大整数类型，**所有运算对象最终都会转换成同一类型**。

1. 运算符%是取余或取模运算符。**参与取余（%）运算的运算符必须是整数类型**。

1. **c++11新标准规定，商的值一律向0取整。**

1. 对于取模运算符（%）来说，如果 m % n 的运算结果不等于0，则它的符号与m相同。**而 (-m) / n 和 m / (-n) 都等于 -(m / n)，m % (-n) 等于 m % n，(-m) % n 等于 -(m % n)**。

    | 运算     | 结果 |
    | -------- | ---- |
    | 21 % 6   | 3    |
    | 21 % 7   | 0    |
    | -21 % -8 | -5   |
    | 21 % -5  | 1    |

1. 逻辑运算符和关系运算符的运算对象求值结果为右值

1. **如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。**

1. **如果左值是一个内置类型，那么初始值列表最多只能包含一个值**

1. **赋值运算符满足右结合律**：

    ```c++
    int i, j;
    i = j = 0; // 正确，i和j都被赋值为0。 0先被赋值给j，然后j赋值给i
    int *ptr;
    i = ptr = 0; // 错误，不能把int* 赋值给一个int对象

    double d;
    d = i = 3.5; // d是3.0, i是3
    i = d = 3.5; // d是3.5，i是3
    ```

1. 赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号：

1. ++操作的优先级高于解引用(*)。先对pbeg进行++操作，然后再返回其原始值给解引用操作符，此时解引用操作符返回的是pbeg未增加之前的值。此处可以有效避免解引用操作符操作一个先进行++再返回++之后的对象，因为此时对象可能已经指向一个未知的或不存在的元素，导致解引用发生不可预知的错误。

    ```c++
    cout << *iter++ << endl; // 习惯这种操作，更加简洁也更少出错

    cout << *iter << endl; // 尽量避免这种操作
    iter++;
    ```

1. 因为递增运算符和递减运算符会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。

    ```c++
    while(beg != s.end() && !isspace(*beg))
        *beg = toupper(*beg++); // 错误，赋值运算符两端的运算对象都用到了beg，
                                // 并且右侧的运算对象还改变了beg的值，
                                // 此时无法知道先运算左边还是右边

    if(vec[i++] <= vec[i]){
        // 同样地，此时也不能明确左右哪边先运算，也会导致该赋值是未定义的
    }
    ```

1. 4.20例题，假设iter的类型是vector<string>::iterator,说明下面的表达式是否合法：

    ```c++
    *iter++; // 解引用操作优先级小于++，所以先保存值再加加再返回原来的值，合法
    (*iter)++; // 先解引用为string类型，再++，string++无意义，不合法
    *iter.empty(); // 解引用操作优先级小于点操作，先对iter进行empty成员函数，
                   // 指针无该成员函数，不合法
    iter->empty(); // 合法
    ++*iter; // 先进行++，但++操作符操作于*iter解引用的string类型上，无意义
    iter++->empty(); // ++操作符优先级低于箭头操作符，先调用empty成员函数，
                     // 再进行++，合法
    ```

1. 条件运算符的内部允许嵌套另外一个条件运算符。

    ```c++
    string finalgrade = (grad < 60) ? "Fail" : (grad > 90) ? "High Pass" : "Pass";
    ```

1. 条件运算符满足右结合律，意味着运算对象（一般）按照从右向左的顺序组合。因此上述代码中，靠右边的条件运算（grad > 90）构成了左边的条件运算的分支。

1. 条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要再它两端加上括号。

    ```c++
    cout << ((grade < 60) ? "fail" : "pass"); // 输出pass或者fail
    cout << (grade < 60) ? "fail" : "pass"; // 输出0或者1,解释在下条
    cout << grade < 60 ? "fail" : "pass"; // 错误，试图比较cout和60
    ```

1. **左移运算符在右侧插入值为0的二进制位。右移运算符则依赖于运算对象的类型：如果是无符号类型，则在左侧的二进制位插入0，如果是带符号，则左侧插入符号位的副本或值为0的二进制数。具体视环境而定。**

1. 位移操作符满足左结合律，它们的重载版本可以进行IO操作。位移操作的优先级不高不低，介于中间：比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高。因此在一次使用多个运算符时，有必要适当的地方加上括号使其满足我们的要求。

    ```c++
    cout << 42 + 10; // 正确，+优先级更高，因此输出求和的结果
    cout << (10 < 42); // 正确，括号使得运算对象按照我们的期望组合在一起，输出1
    cout << 10 < 42; // 错误：试图比较cout对象和42的大小
    ```

1. sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。

1. 最有意思的是sizeof \*p，首先因为sizeof满足右结合律并且与\*的运算符的优先级一样，所以表达式按照从右向左的顺序组合。也就是说，他等价于sizeof(*p)。其次，因为sizeof不会实际求运算对象的值，所以即使p是一个无效的（未初始化的）指针，也不会有什么影响。**在sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为**，因为指针实际上并没有被真正的使用。sizeof不需要真的解引用指针也能知道他所指对象的类型。

1. 对char或者类型为char的表达式执行sizeof运算，结果为1。

1. 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。

1. sizeof的返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度。

    ```c++
    // 可以用数组的大小除以单个元素的大小得到数组中元素的个数
    constexpr size_t sz = sizeof(ia) / sizeof(*ia);
    int arr2[sz]; // 正确，sizeof返回的是一个常量表达式（数组在声明时长度必须是常量）
    ```

1. 习题4.33:

    someValue ? ++x, ++y : --x, --y
    逗号表达式的优先级是最低的。因此这条表达式也等于：

    (someValue ? ++x, ++y : --x), --y
    如果 someValue的值为真，x 和 y 的值都自增并返回 y 值，然后丢弃 y 值，y递减并返回 y 值。如果 someValue的值为假，x 递减并返回 x 值，然后丢弃 x 值，y递减并返回 y 值。

1. **算术类型之间的隐式转换被设计的尽可能避免损失精度**，很多时候，如果表达式中既有整数又有浮点数那么整型会被转换成浮点型。

1. **指向任意非常量的指针能转换成void\*静态指针**。

1. static_cast:任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。例如，通过将一个运算对象强制转换成double类型以执行浮点数除法：

    ```c++
    double slope = static_cast<double>(j) / i;
    ```

1. 当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时强制类型转换会告诉读者和编译器，我们知道并且不在乎潜在的精度损失。（如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息，但是当执行了显式的类型转换后，警告信息就会被关闭了）

## Chapter 5

1. case关键字和他对应的值一起被称为case标签（case label）。case标签必须是整型常量表达式：

    ```c++
    char ch = getVal();
    int ival = 42;
    switch(ch){
        case 3.15: // 错误，case标签不是一个整数
        case ival: // 错误，case标签不是一个常量
    }
    ```

1. 标签不应该孤零零的出现，它后面必须跟上一条语句或者另外一个case标签。如果switch结构以一个空的default标签作为结束，则该default标签背后必须跟上一条空语句或者空块。

    ```c++
        int b = 4;
        switch(b){
            case 3:
                cout << "b is 3" << endl;
                break;
            default: ; // default 以空语句结尾，注意不要省略：
        }
    ```

1. **try语句块内的变量在块外部无法访问，特别是在catch子句内也无法访问。**

1. **我们只能用默认初始化的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。其他异常类型则恰好相反，应该使用string对象或者c风格字符串初始化这些类型的对象，且不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。**

## chapter 6

1. 因为顶层 const 被忽略掉，**所以对于相同名字的函数，形参表中的 const 不能区分这些函数，导致重复定义（而非函数重载）**。

1. 把函数不会改变的形参定义成普通引用是一种比较常见的错误，这么做带给函数调用者一种误导，即函数可以修改他的实参的值。此外，使用一般引用而非常量引用也会极大地限制函数所能接受的实参类型。例如，我们不能把 const 对象、字面值或者需要类型转换的对象，传递给普通的引用形参。

   ```c++
   string::size_type find_char(string &s, char c, string::size_type &occurs){
       // string &s是一个不良设计，因为此时find_char（“Hello World", 'o', ctr)将会报错
   }
   ```

1. 我们不能以值传递的方式传递数组，但可以把形参写成类似数组的形式：

   ```c++
   void print(const int*);
   void print(const int[]); // 表明传递数组的意图
   void print(const int[10]); //实际并不一定要10个元素的数组传递
   ```

1. 可以使用数组的引用形参来传递，但是需要注意不要忽略对引用的名称加上括号。

   ```c++
   void print(int (&arr)[10]){ //不加括号则错误，意为引用的数组（不存在）
       //code_block
   }
   ```

1. 二维数组实际是一个数组的数组。数组第二维的大小都是数组类型的一部分，不能省略。有两种参数定义方法：

   ```c++
   void print(int (*matrix)[10], int row_size); // 注意不要忽略括号，同上
   void print(int matrix[][10], int row_size); // 注意不要忽略第二个维度10
   ```

1. 函数的返回类型决定函数调用是否是左值。**调用一个返回引用的函数得到左值**，其他类型则得到右值。可以像使用其他左值那样来使用返回引用的函数的调用。**如果返回类型是常量引用，我们不能给调用的结果赋值**。

   ```c++
   char &get_val(string &str, string::size_type ix){
       return str(ix);
   }
   int main(){
       string s("a value");
       cout << s << endl;
       get_val(s, 0) = 'A'; // 将s[0]的值该位A
       cout << s << endl;
       return 0;
   }
   ```

1. 因为数组不能拷贝，所以函数不能返回数组。但是函数可以返回数组的指针或引用。以下几种可以返回数组指针的引用或指针的方式：

   1. 使用类型别名：

      ```c++
      typedef int arrT[10]; // arrT是一个类型别名
      using arrT[10] = int[10]; // arrT的等价声明
      arrT* func(int i); // func返回一个指向含有10个整数的数组的指针
      ```

   2. 声明一个返回数组指针的函数( _Type (\*function(parameter_list)) [dimention]_ )：

      ```c++
      int (*func(int i))[10];
      ```

      上述代码的解释含义：

      1. func(int i)表示调用 func 函数时需要一个 int 类型的实参
      2. (\*func(int i))意味着我们可以对函数调用的结果执行解引用操作
      3. (\*func(int i))[10]表示解引用 func 的调用将得到一个大小是 10 的数组
      4. int (\*func(int i))[10]表示数组中的元素是 int 类型的

   3. 使用尾置返回类型：

      ```c++
      // func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组
      auto func(int i) -> int(*)[10]
      ```

   4. 使用 decltype

      ```c++
      int odd[] = {1, 3, 5, 7, 9};
      int even[] = {2, 4, 6, 8, 10};

      // arrPtr返回一个指针，并且类型和odd一致
      decltype(odd) *arrPtr(int i){
          return (i % 2) ? &odd : &even; // 返回一个指向数组的指针
      }
      // decltype简洁，尽量使用decltype
      ```

1. **顶层 const 不影响传入函数的对象。一个拥有顶层 const 的形参无法和另一个没有顶层 const 的形参区分开来。**

1. 如果形参是某种类型的指针或者引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载。**底层 const 可以区分函数重载。**

1. **注意，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。所以上述代码中如果一定要为 backgrnd 覆盖默认值，则必须为 ht 和 wid 提供实参。所以当设计含有默认实参的函数时，尽量让不怎么使用默认值的形参出现在前面，让那些经常使用默认值的形参出现在后面。**

1. **在给定的作用域中，一个形参只能被赋值一次默认实参。在函数的多次声明中，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。**

   ```c++
   string screen(sz, sz, char = ' '); // 初次声明
   // 错误，char已经被赋值了一次默认实参，不能重复声明
   string screen(sz, sz, char = '*');
   // 正确，为之前没有添加默认实参的形参添加默认实参
   string screen(sz = 24, sz = 80, char);
   ```

1. **constexpr 函数是指能用于常量表达式的函数。函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须只有一条 return 语句。**

   ```c++
   constexpr int new_sz(){ return 42; }
   constexpr int foo = new_sz(); // 正确，foo是一个常量表达式
   ```

1. 当有两个函数一个接受 int 一个接受 short，则当且仅当调用提供的是 short 类型的值时才会调用 short 版本的函数。大部分情况下小整型都会被提升为 int 型（char或者short都会先转成int）。

   ```c++
   void ff(int);
   void ff(short);
   ff('a'); // char提升为int型

   void manp(long);
   void manp(float);

   manip(3.14); // double既能转换成long又能转换成float，二义性调用，错误
   ```

1. 当我们把函数名作为一个值使用时，该函数自动转换成指针。

    ```c++
    pf = lengthCompare; // pf指向名为lengthCompare的指针
    pf = &lengthCompare; // 等价赋值语句
    ```

## chapter 7

1. **任何自定义名为this的参数或变量的行为都是非法的。this的目的总是指向“这个”对象，所以this是一个常量指针（*const），我们不允许改变this中保存的地址。**

1. 常量对象，以及常量对象的引用或指针只能调用常量成员函数。

1. 如果函数在概念上属于类但是不定义在类中，则一般他们应与类声明（而非定义）在同一个头文件中。

1. 下面代码定义了read和print函数，比较重要的一点是，read和print分别接收一个来自IO类型的引用作为其参数，这是因为**IO类属于不能被拷贝的类型**，因此我们只能通过引用来传递他们。而且因为**读取和写入的操作会改变数据流中的内容，所以两个函数接收的都是普通引用，而非对常量的引用**。

1. **构造函数的名字和类相同，没有返回类型**。类可以包含多个构造函数，但是每个构造函数必须在参数数量或参数类型上有所区别。构造函数不能被声明成const。**构造函数在const对象的构造过程中可以向其写值。**

1. **如果定义在块中的内置类型或复合类型（数组、指针等）的对象被编译器默认初始化将出现未定义的值。所以当我们使用内置类型或复合类型成员的类，应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数**。

1. 定义默认构造函数，我们可以使用C++11新标准中，通过在参数列表后面写上=default来要求编译器生成构造函数。=default既可以声明在类内部（那么就是内联的），也可以声明在类外部（非内联）。

1. 当我们提供类内初始值时，必须使用符号“=”或者花括号表示。

    ```c++
    // 我们定义了一个窗口管理类并用它表示显示器上的一组Screen
    using namespace std;
    class Window_mgr{
        private:
            vector<Screen> screens{Screen(24, 80, ' ')}; //使用花括号进行类内初始化
    };
    ```

1. **友元的声明仅仅是指定了访问权限，我们仍然必须在友元之外再专门对函数进行一次声明**。为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。

1. **我们可以仅仅声明一个类而暂时不定义它，此时叫做向前声明（forward declaration），它向程序中引入了类名，并且指明该类名是一种类类型。对于这样的类型来说，在他声明之后、定义之前是一个不完全类型（incomplete type）对于不完全类型，我们可以定义指向这种类型的指针或者引用，也可以声明（但是不能定义）以不完全类型作为参数或返回类型的函数。**

1. **创建对象或通过指针、引用之前，该类必须有定义，而不能仅仅被声明。（原因是如果只声明，编译器将不知道需要分配多少内存）**

1. **一个类的成员类型不能是该类自己**。然而，一旦一个类名出现后，他就被认为是声明过了（但尚未定义），因此**类允许包含指向它自身类型的引用或指针**。

    ```c++
    class Link_Screen{
        Screen window;
        Link_Screen *next;
        Link_Screen *prev;
    };
    ```

1. **如果一个类想把一组重载函数声明成友元，那么它需要对这组函数中的每一个都分别声明**。

1. 友元声明的作用是影响访问权限，它本身并非普通意义上的声明。**所以即便我们在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。**

    ```c++
    struct X{
        friend void f() {  /*友元被定义在类的内部*/ }
        X(){ f(); } // 错误，f还没有被声明
        void g();
        void h();
    };
    void X::g(){return f(); } // 错误，f还没有被声明
    void f(); // 声明定义在X中的f
    void X::h() { return f(); } //正确，f现在已经在作用域中了
    ```

1. 一般来说，内层作用域可以重新定义外层作用域的名字，即使该名字已经在内层作用域中使用过。然而在类中，**如果成员使用了外层作用域的某个名字，而该名字代表一种类型，则类不能再之后重新定义该名字**：

    ```c++
    typedef double Money;
    string bal;
    class Account{
        private:
            typedef Money; // 错误，不能重新定义Money
            Money bal;
    };
    ```

1. 如果没有在构造函数的初始值列表中显示的初始化成员，则该成员将在构造函数体之前执行默认初始化。

    ```c++
    Sales_data::Sales_data(const string &s, unsigned cnt, double price){
        bookNo = s;
        units_sold = cnt;
        revenue = cnt * price;
    }
    ```

    此段代码和我们之前使用的列表初始化的功能相同，**但是此段代码使用的是赋值操作**。而列表初始化则是直接初始化。

1. 上述初始化过程具有一定的局限性，例如**当我们的成员变量是const或者引用时，此时必须使用列表初始化而不能使用赋值操作**。类似的，**当成员属于某种类类型且该类没有定义默认构造函数时，也必须对该成员进行初始化**。

    ```c++
    class ConstRef{
        public:
            ConstRef(int ii);
        private:
            int i;
            const int ci;
            int &ri;
    }
    ConstRef::ConstRef(int ii){
        i = ii;
        ci = ii; // 错误，ci是const int
        ri = ii; // 错误，ri没有初始化
    }
    // 列表初始化
    ConstRef::ConstRef(int ii):i(ii), ci(ii), ri(ii){ }

1. **初始化和赋值操作的区别事关底层效率问题，前者直接初始化数据成员，后者则先初始化再赋值**。除此以外，一些数据成员必须被初始化。所以我们应该养成使用构造函数初始值的习惯，这样可以避免意想不到的编译错误。

1. **如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数**。

1. 类必须包含一个默认构造函数以便在上述情况下使用。**即便定义了其他构造函数，最好也提供一个默认构造函数**。

1. 一旦我们直接声明了explicit于构造函数前，那么我们**只能使用直接初始化，而不能使用拷贝初始化**。

    ```c++
    Sales_data item1(null_book);
    Sales_data item2 = null_book; // 错误，不能使用拷贝初始化
    ```

1. 聚合类（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足以下条件时我们可以称它为聚合的：
   - 所有成员都是public的
   - 没有定义任何构造函数
   - 没有类内初始值
   - 没有基类，没有virtual函数

    ```c++
    struct Data{
        int ival;
        string s;
    };

    Data val1 = {0, "Anna"};
    // 错误，初始值的顺序必须和声明的顺序一致
    Data val1 = {"Anna", 0};
    ```

1. **构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数**。（一个字面值常量类必须至少提供一个constexpr构造函数）

1. 我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，**静态成员可以是public的或private的。静态数据成员的类型可以是常量，引用或指针、类类型等等**。

1. **静态成员函数不能声明成const，而且也不能在static函数内使用this指针**。

1. 和其他成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数，当在类外定义静态成员函数时，**不能重复static关键字，该关键字只出现在类内部的声明语句**：

1. **由于静态成员不属于任何一个类的对象，所以一般情况下他们不能在类的内部被定义，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次**。

